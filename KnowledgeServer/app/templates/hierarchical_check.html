<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hierarchical Map API Check</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 50px auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #333;
            margin-bottom: 30px;
            text-align: center;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        label {
            font-weight: bold;
            color: #555;
            font-size: 14px;
        }
        
        input, select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        button {
            background-color: #9C27B0;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
            font-weight: bold;
        }
        
        button:hover {
            background-color: #7B1FA2;
        }
        
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        #status {
            margin-top: 20px;
            padding: 10px;
            border-radius: 4px;
            display: none;
        }
        
        .success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .loading {
            background-color: #cce5ff;
            color: #004085;
            border: 1px solid #b8daff;
        }
        
        #results {
            margin-top: 20px;
            display: none;
        }
        
        pre {
            background-color: #f8f8f8;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
            border: 1px solid #ddd;
            font-size: 12px;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .stat-box {
            background-color: #f0f0f0;
            padding: 15px;
            border-radius: 4px;
            text-align: center;
        }
        
        .stat-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #333;
        }
        
        .visualization-container {
            margin-top: 30px;
            padding: 20px;
            background-color: #fafafa;
            border-radius: 8px;
            border: 1px solid #ddd;
        }
        
        #hierarchical-canvas {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            display: block;
            margin: 0 auto;
        }
        
        .region-legend {
            margin-top: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 5px 10px;
            background: white;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        
        .section-header {
            background: linear-gradient(135deg, #9C27B0, #E1BEE7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="section-header">
            üó∫Ô∏è Hierarchical Voronoi Map Generator
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label for="n">Number of images:</label>
                <input type="number" id="n" value="100" min="10" max="1000">
            </div>
            
            <div class="control-group">
                <label for="method">Embedding method:</label>
                <select id="method">
                    <option value="clip">CLIP (multimodal)</option>
                    <option value="resnet">ResNet50 (image only)</option>
                </select>
            </div>

            <div class="control-group">
                <label for="k">Number of regions:</label>
                <input type="number" id="k" value="10" min="3" max="50">
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label for="n_neighbors">UMAP n_neighbors:</label>
                <input type="number" id="n_neighbors" min="2" max="1000" value="500" placeholder="default 500">
            </div>
            <div class="control-group">
                <label for="min_dist">UMAP min_dist:</label>
                <input type="number" id="min_dist" min="0" max="1" step="0.01" value="0.9" placeholder="default 0.9">
            </div>
            <div class="control-group">
                <label for="random_state">UMAP random_state:</label>
                <input type="number" id="random_state" min="0" max="999999" value="42" placeholder="default 42">
            </div>
            <div class="control-group">
                <label for="kmeans_iter">K-means iterations:</label>
                <input type="number" id="kmeans_iter" min="10" max="500" value="50" placeholder="default 50">
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label>
                    <input type="checkbox" id="random" style="margin-right: 5px;">
                    Random selection
                </label>
            </div>
            <div class="control-group">
                <label>
                    <input type="checkbox" id="disk" checked style="margin-right: 5px;">
                    Use disk images
                </label>
            </div>
            <div class="control-group">
                <label>
                    <input type="checkbox" id="debug" checked style="margin-right: 5px;">
                    Debug mode
                </label>
            </div>
            <div class="control-group">
                <label>
                    <input type="checkbox" id="cache" style="margin-right: 5px;">
                    Use cache
                </label>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label for="pairingStrategy">Pairing strategy:</label>
                <select id="pairingStrategy">
                    <option value="longest_boundary">Longest Boundary (default)</option>
                    <option value="boundary_segments">Boundary Segments</option>
                    <option value="boundary_ratio">Boundary Ratio</option>
                    <option value="compactness">Compactness</option>
                </select>
                <small style="display: block; color: #666; margin-top: 5px; font-size: 12px;">
                    Strategy for optimal region pairing: Longest boundary length, number of boundary segments, boundary ratio, or shape compactness
                </small>
            </div>
        </div>
        
        <button id="generateBtn" onclick="generateHierarchicalMap()">
            üó∫Ô∏è Generate Hierarchical Voronoi Map
        </button>
        
        <button id="adjacencyBtn" onclick="analyzeAdjacency()" disabled style="background-color: #FF8C00; margin-left: 10px;">
            üîó Analyze Adjacency
        </button>
        
        <button id="mergeBtn" onclick="mergeRegions()" disabled style="background-color: #4CAF50; margin-left: 10px;">
            üîó Merge Paired Regions
        </button>
        
        <div id="status"></div>
        <div id="timer" style="margin-top:8px;font-size:14px;color:#666;display:none;"></div>
        
        <div id="results">
            <h3>Hierarchical Map Results</h3>
            <div class="stats" id="stats"></div>
            
            <div class="visualization-container">
                <h4 style="text-align: center; margin-bottom: 15px;">Voronoi Region Visualization</h4>
                <canvas id="hierarchical-canvas" width="800" height="600"></canvas>
                <div class="region-legend" id="region-legend"></div>
            </div>
            
            <details style="margin-top: 20px;">
                <summary style="cursor: pointer; font-weight: bold;">View Raw Response</summary>
                <pre id="response"></pre>
            </details>
        </div>
    </div>

    <script>
        let currentMapData = null;
        let currentAdjacencyData = null;
        const regionColors = [
            '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3', '#54a0ff', '#5f27cd', '#00d2d3', '#ff6348',
            '#ff7675', '#74b9ff', '#0984e3', '#00b894', '#00cec9', '#fdcb6e', '#e17055', '#fd79a8', '#6c5ce7', '#a29bfe',
            '#2d3436', '#636e72', '#fab1a0', '#e84393', '#00b894', '#6c5ce7', '#fd79a8', '#fdcb6e', '#55a3ff', '#81ecec'
        ];

        let timerInterval = null;
        let timerStart = null;

        function startTimer() {
            timerStart = Date.now();
            const timerDiv = document.getElementById('timer');
            timerDiv.style.display = 'block';
            timerDiv.textContent = "Elapsed: 0.00s";
            timerInterval = setInterval(() => {
                const elapsed = ((Date.now() - timerStart) / 1000).toFixed(2);
                timerDiv.textContent = `Elapsed: ${elapsed}s`;
            }, 50);
        }

        function stopTimer(finalText) {
            clearInterval(timerInterval);
            timerInterval = null;
            const timerDiv = document.getElementById('timer');
            if (finalText) {
                timerDiv.textContent = finalText;
            }
        }

        async function generateHierarchicalMap() {
            const btn = document.getElementById('generateBtn');
            const status = document.getElementById('status');
            const results = document.getElementById('results');
            const responseDiv = document.getElementById('response');
            const statsDiv = document.getElementById('stats');

            // Get parameters
            const n = document.getElementById('n').value;
            const method = document.getElementById('method').value;
            const k = document.getElementById('k').value;
            const n_neighbors = document.getElementById('n_neighbors').value;
            const min_dist = document.getElementById('min_dist').value;
            const random_state = document.getElementById('random_state').value;
            const kmeans_iter = document.getElementById('kmeans_iter').value;
            const random = document.getElementById('random').checked;
            const disk = document.getElementById('disk').checked;
            const debug = document.getElementById('debug').checked;
            const cache = document.getElementById('cache').checked;

            // Build query string
            let query = `n=${n}&method=${method}&k=${k}&debug=${debug}&random=${random}&disk=${disk}&cache=${cache}`;
            if (n_neighbors) query += `&n_neighbors=${n_neighbors}`;
            if (min_dist) query += `&min_dist=${min_dist}`;
            if (random_state) query += `&random_state=${random_state}`;
            if (kmeans_iter) query += `&kmeans_iter=${kmeans_iter}`;

            btn.disabled = true;
            status.className = 'loading';
            status.textContent = `Generating hierarchical Voronoi map with ${n} images, ${k} regions using ${method.toUpperCase()} embeddings...`;
            status.style.display = 'block';
            results.style.display = 'none';
            startTimer();

            const startTime = Date.now();

            try {
                const response = await fetch(`/generate_hierarchical_voronoi_map?${query}`);
                const data = await response.json();

                const elapsed = ((Date.now() - startTime) / 1000).toFixed(2);
                stopTimer(`Total time: ${elapsed}s`);

                if (data.success) {
                    status.className = 'success';
                    status.textContent = `Success! Generated hierarchical map with ${data.count} points and ${k} regions in ${elapsed} seconds.`;

                    // Display stats
                    const hierarchicalStats = data.voronoiData?.hierarchicalStats || {};
                    statsDiv.innerHTML = `
                        <div class="stat-box">
                            <div class="stat-label">Total Images</div>
                            <div class="stat-value">${data.count}</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Voronoi Regions</div>
                            <div class="stat-value">${hierarchicalStats.totalRegions || k}</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Avg Points/Region</div>
                            <div class="stat-value">${(hierarchicalStats.averagePointsPerRegion || 0).toFixed(1)}</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Largest Region</div>
                            <div class="stat-value">${hierarchicalStats.largestRegion || 0}</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Smallest Region</div>
                            <div class="stat-value">${hierarchicalStats.smallestRegion || 0}</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Method</div>
                            <div class="stat-value">${method.toUpperCase()}</div>
                        </div>
                    `;

                    responseDiv.textContent = JSON.stringify(data, null, 2);
                    results.style.display = 'block';

                    // Store map data
                    currentMapData = data;
                    currentMapData.mergeIterations = 0; // Initialize merge counter
                    currentAdjacencyData = null; // Reset adjacency data
                    
                    // Enable both adjacency analysis and merge buttons
                    document.getElementById('adjacencyBtn').disabled = false;
                    document.getElementById('mergeBtn').disabled = false;
                    
                    // Draw the hierarchical visualization
                    if (data.imagePoints && data.voronoiData) {
                        drawHierarchicalVisualization(data.imagePoints, data.voronoiData);
                    }
                } else {
                    status.className = 'error';
                    status.textContent = `Error: ${data.error}`;
                    responseDiv.textContent = JSON.stringify(data, null, 2);
                    results.style.display = 'block';
                    clearVisualization();
                }
            } catch (error) {
                stopTimer();
                status.className = 'error';
                status.textContent = `Network error: ${error.message}`;
                clearVisualization();
            } finally {
                btn.disabled = false;
            }
        }

        async function analyzeAdjacency() {
            if (!currentMapData || !currentMapData.voronoiData) {
                alert('Please generate a hierarchical map first!');
                return;
            }

            const btn = document.getElementById('adjacencyBtn');
            const status = document.getElementById('status');

            btn.disabled = true;
            const pairingStrategy = document.getElementById('pairingStrategy').value;
            const strategyName = document.getElementById('pairingStrategy').selectedOptions[0].text;
            status.className = 'loading';
            status.textContent = `Analyzing Voronoi region adjacencies using ${strategyName}...`;
            status.style.display = 'block';

            try {
                const pairingStrategy = document.getElementById('pairingStrategy').value;
                const response = await fetch('/analyze_voronoi_adjacency', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        voronoiData: currentMapData.voronoiData,
                        pairingStrategy: pairingStrategy,
                        debug: document.getElementById('debug').checked
                    })
                });

                const data = await response.json();

                if (data.success) {
                    status.className = 'success';
                    const adjStats = data.stats;
                    const strategyName = document.getElementById('pairingStrategy').selectedOptions[0].text;
                    status.textContent = `Success! Using ${strategyName}: Found ${adjStats.optimalPairs} optimal pairs (${adjStats.pairedBoundaries} paired boundaries, ${adjStats.unpairedBoundaries} unpaired boundaries).`;
                    
                    // Store adjacency data
                    currentAdjacencyData = data;
                    
                    // Merge button is already enabled - it works independently of adjacency analysis
                    
                    // Update visualization with adjacency highlighting
                    drawAdjacencyVisualization(currentMapData.imagePoints, currentMapData.voronoiData, data);
                    
                    // Update stats to include adjacency info
                    updateStatsWithAdjacency(adjStats);
                } else {
                    status.className = 'error';
                    status.textContent = `Error: ${data.error}`;
                }
            } catch (error) {
                status.className = 'error';
                status.textContent = `Network error: ${error.message}`;
            } finally {
                btn.disabled = false;
            }
        }

        async function mergeRegions() {
            if (!currentMapData || !currentMapData.voronoiData) {
                alert('Please generate a hierarchical map first!');
                return;
            }

            const btn = document.getElementById('mergeBtn');
            const status = document.getElementById('status');

            btn.disabled = true;
            const pairingStrategy = document.getElementById('pairingStrategy').value;
            const strategyName = document.getElementById('pairingStrategy').selectedOptions[0].text;
            status.className = 'loading';
            status.textContent = `Merging paired Voronoi regions using ${strategyName}...`;
            status.style.display = 'block';

            try {
                const pairingStrategy = document.getElementById('pairingStrategy').value;
                const response = await fetch('/merge_voronoi_regions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        voronoiData: currentMapData.voronoiData,
                        imagePoints: currentMapData.imagePoints,
                        pairingStrategy: pairingStrategy,
                        debug: document.getElementById('debug').checked
                    })
                });

                const data = await response.json();

                if (data.success) {
                    status.className = 'success';
                    const mergeStats = data.mergeStats;
                    
                    if (mergeStats.mergedPairs > 0) {
                        // Increment merge iteration counter
                        currentMapData.mergeIterations = (currentMapData.mergeIterations || 0) + 1;
                        
                        status.textContent = `Success! Merge iteration ${currentMapData.mergeIterations}: Merged ${mergeStats.mergedPairs} pairs. Total regions: ${mergeStats.originalRegions} ‚Üí ${mergeStats.mergedRegions}`;
                        
                        // Update current map data with merged data
                        currentMapData.voronoiData = data.mergedVoronoiData;
                        currentMapData.imagePoints = data.mergedImagePoints;
                        
                        // Reset adjacency data since regions have changed
                        currentAdjacencyData = null;
                        
                        // Update button text for repeated merging
                        const mergeBtn = document.getElementById('mergeBtn');
                        mergeBtn.innerHTML = `üîó Merge Again! (${currentMapData.mergeIterations + 1})`;
                        mergeBtn.disabled = false; // Keep enabled for repeated merging
                        
                        // Keep adjacency button enabled
                        document.getElementById('adjacencyBtn').disabled = false;
                        
                        // Update visualization with merged regions
                        drawHierarchicalVisualization(currentMapData.imagePoints, currentMapData.voronoiData);
                        
                        // Update stats to include merge info
                        updateStatsWithMerge(mergeStats);
                    } else {
                        status.textContent = `No adjacent pairs found to merge. Map fully optimized after ${currentMapData.mergeIterations || 0} merge iterations with ${mergeStats.mergedRegions} final regions.`;
                        
                        // Disable merge button if no more pairs can be merged
                        const mergeBtn = document.getElementById('mergeBtn');
                        mergeBtn.disabled = true;
                        mergeBtn.innerHTML = 'üîó No More Pairs to Merge';
                    }
                } else {
                    status.className = 'error';
                    status.textContent = `Error: ${data.error}`;
                }
            } catch (error) {
                status.className = 'error';
                status.textContent = `Network error: ${error.message}`;
            } finally {
                btn.disabled = false;
            }
        }

        function updateStatsWithAdjacency(adjStats) {
            const statsDiv = document.getElementById('stats');
            const hierarchicalStats = currentMapData.voronoiData?.hierarchicalStats || {};
            
            statsDiv.innerHTML = `
                <div class="stat-box">
                    <div class="stat-label">Total Images</div>
                    <div class="stat-value">${currentMapData.count}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Voronoi Regions</div>
                    <div class="stat-value">${hierarchicalStats.totalRegions || currentMapData.generationParams.k}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Optimal Pairs</div>
                    <div class="stat-value">${adjStats.optimalPairs}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Unpaired Regions</div>
                    <div class="stat-value">${adjStats.unpairedRegions}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Paired Boundaries</div>
                    <div class="stat-value">${adjStats.pairedBoundaries}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Method</div>
                    <div class="stat-value">${currentMapData.method.toUpperCase()}</div>
                </div>
            `;
        }

        function updateStatsWithMerge(mergeStats) {
            const statsDiv = document.getElementById('stats');
            
            statsDiv.innerHTML = `
                <div class="stat-box">
                    <div class="stat-label">Total Images</div>
                    <div class="stat-value">${currentMapData.count}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Merge Iterations</div>
                    <div class="stat-value">${currentMapData.mergeIterations || 0}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Current Regions</div>
                    <div class="stat-value">${mergeStats.mergedRegions}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Last Merge: Pairs</div>
                    <div class="stat-value">${mergeStats.mergedPairs}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Unmerged Regions</div>
                    <div class="stat-value">${mergeStats.unmergedRegions}</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Method</div>
                    <div class="stat-value">${currentMapData.method.toUpperCase()}</div>
                </div>
            `;
        }

        function drawAdjacencyVisualization(imagePoints, voronoiData, adjacencyData) {
            const canvas = document.getElementById('hierarchical-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const cells = voronoiData.cells || [];
            const legendDiv = document.getElementById('region-legend');
            const regionColors = adjacencyData.visualizationData.regionColors;
            const boundaryColors = adjacencyData.visualizationData.boundaryColors;
            const sharedBoundaries = adjacencyData.adjacencyData.sharedBoundaries;
            
            // Clear legend
            legendDiv.innerHTML = '';

            // Find min/max for scaling
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            imagePoints.forEach(pt => {
                if (pt.x < minX) minX = pt.x;
                if (pt.x > maxX) maxX = pt.x;
                if (pt.y < minY) minY = pt.y;
                if (pt.y > maxY) maxY = pt.y;
            });

            const pad = 40;
            const plotW = canvas.width - pad * 2;
            const plotH = canvas.height - pad * 2;

            // Helper function to scale coordinates
            const scalePoint = (x, y) => ({
                x: pad + ((x - minX) / (maxX - minX)) * plotW,
                y: pad + ((y - minY) / (maxY - minY)) * plotH
            });

            // Draw Voronoi regions with adjacency colors
            cells.forEach((cell, idx) => {
                const regionId = cell.id.toString();
                const color = regionColors[regionId] || '#cccccc';
                
                if (cell.vertices && cell.vertices.length > 2) {
                    ctx.beginPath();
                    
                    // Scale vertices to canvas
                    const scaledVertices = cell.vertices.map(v => scalePoint(v[0], v[1]));
                    
                    // Draw region polygon
                    ctx.moveTo(scaledVertices[0].x, scaledVertices[0].y);
                    for (let i = 1; i < scaledVertices.length; i++) {
                        ctx.lineTo(scaledVertices[i].x, scaledVertices[i].y);
                    }
                    ctx.closePath();
                    
                    // Fill with adjacency color (more opaque for adjacent regions)
                    if (color === '#cccccc') {
                        ctx.fillStyle = color + '40'; // Light gray for non-adjacent
                    } else {
                        ctx.fillStyle = color + '60'; // More opaque for adjacent pairs
                    }
                    ctx.fill();
                    
                    // Stroke with region color
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Draw region centroid
                if (cell.centroid && cell.centroid.length === 2) {
                    const scaled = scalePoint(cell.centroid[0], cell.centroid[1]);
                    
                    // Draw centroid as a larger circle
                    ctx.beginPath();
                    ctx.arc(scaled.x, scaled.y, 8, 0, 2 * Math.PI);
                    ctx.fillStyle = color;
                    ctx.fill();
                    ctx.strokeStyle = "#000";
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Add white center dot
                    ctx.beginPath();
                    ctx.arc(scaled.x, scaled.y, 3, 0, 2 * Math.PI);
                    ctx.fillStyle = "#fff";
                    ctx.fill();

                    // Draw region label
                    ctx.font = "12px Arial";
                    ctx.fillStyle = "#000";
                    ctx.textAlign = "center";
                    ctx.fillText(cell.clusterLabel || `R${cell.id}`, scaled.x, scaled.y - 12);
                }

                // Add to legend with pairing status
                const legendItem = document.createElement('div');
                legendItem.className = 'legend-item';
                const isPaired = color !== '#cccccc';
                const status = isPaired ? ' (Paired)' : ' (Unpaired)';
                legendItem.innerHTML = `
                    <div class="legend-color" style="background-color: ${color}"></div>
                    <span>${cell.clusterLabel || `Region ${cell.id + 1}`} (${cell.pointCount})${status}</span>
                `;
                legendDiv.appendChild(legendItem);
            });

            // Draw shared boundaries with appropriate colors
            sharedBoundaries.forEach(boundary => {
                const boundaryKey = `${Math.min(...boundary.regionIds)}-${Math.max(...boundary.regionIds)}`;
                const color = boundaryColors[boundaryKey] || '#000000';
                const isPaired = boundary.isPaired || false;
                
                boundary.boundarySegments.forEach(segment => {
                    if (segment.length >= 2) {
                        ctx.beginPath();
                        ctx.strokeStyle = color;
                        ctx.lineWidth = isPaired ? 5 : 3; // Thicker lines for paired boundaries
                        
                        const startScaled = scalePoint(segment[0][0], segment[0][1]);
                        ctx.moveTo(startScaled.x, startScaled.y);
                        
                        for (let i = 1; i < segment.length; i++) {
                            const scaled = scalePoint(segment[i][0], segment[i][1]);
                            ctx.lineTo(scaled.x, scaled.y);
                        }
                        
                        ctx.stroke();
                    }
                });
            });

            // Draw image points on top
            imagePoints.forEach(pt => {
                const scaled = scalePoint(pt.x, pt.y);
                
                // Get region color if available
                let pointColor = "#333";
                if (pt.hierarchicalInfo && pt.hierarchicalInfo.regionId !== undefined) {
                    const regionId = pt.hierarchicalInfo.regionId.toString();
                    pointColor = regionColors[regionId] || "#333";
                }
                
                ctx.beginPath();
                ctx.arc(scaled.x, scaled.y, 4, 0, 2 * Math.PI);
                ctx.fillStyle = pointColor;
                ctx.fill();
                ctx.strokeStyle = "#fff";
                ctx.lineWidth = 1;
                ctx.stroke();
            });

            // Add hover functionality (same as before)
            canvas.onmousemove = function(e) {
                const rect = canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;
                
                let hoverIdx = null;
                imagePoints.forEach((pt, i) => {
                    const scaled = scalePoint(pt.x, pt.y);
                    if (Math.hypot(mx - scaled.x, my - scaled.y) < 8) {
                        hoverIdx = i;
                    }
                });
                
                // Redraw to clear previous tooltip
                drawAdjacencyVisualization(imagePoints, voronoiData, adjacencyData);
                
                if (hoverIdx !== null) {
                    const pt = imagePoints[hoverIdx];
                    // Draw tooltip
                    ctx.save();
                    ctx.font = "12px Arial";
                    ctx.textAlign = "left";
                    
                    let label = pt.artworkData?.value || pt.entryId;
                    let artist = "";
                    try {
                        const names = JSON.parse(pt.artworkData?.artist_names || "[]");
                        artist = Array.isArray(names) ? names.join(", ") : names;
                    } catch { 
                        artist = pt.artworkData?.artist_names || "Unknown";
                    }
                    
                    let region = "";
                    if (pt.hierarchicalInfo) {
                        const regionId = pt.hierarchicalInfo.regionId.toString();
                        const isPaired = regionColors[regionId] !== '#cccccc';
                        region = (pt.hierarchicalInfo.regionLabel || `Region ${pt.hierarchicalInfo.regionId + 1}`) + 
                                (isPaired ? ' (Paired)' : ' (Unpaired)');
                    }
                    
                    const text = `${label}\n${artist}\n${region}`;
                    const lines = text.split('\n');
                    const tw = Math.max(...lines.map(l => ctx.measureText(l).width));
                    const th = lines.length * 16 + 10;
                    
                    let tx = mx + 10, ty = my - th - 10;
                    if (tx + tw + 20 > canvas.width) tx = canvas.width - tw - 20;
                    if (ty < 0) ty = my + 10;
                    
                    // Draw background rectangle
                    ctx.beginPath();
                    ctx.rect(tx, ty, tw + 20, th);
                    ctx.fillStyle = "#222";
                    ctx.globalAlpha = 0.92;
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                    ctx.strokeStyle = "#fff";
                    ctx.stroke();
                    
                    // Draw text
                    ctx.fillStyle = "#fff";
                    ctx.textAlign = "left";
                    lines.forEach((l, i) => {
                        ctx.fillText(l, tx + 10, ty + 18 + i * 16);
                    });
                    ctx.restore();
                }
            };

            canvas.onmouseleave = function() {
                drawAdjacencyVisualization(imagePoints, voronoiData, adjacencyData);
            };

            // Add legend items for boundary types
            const pairedBoundaryItem = document.createElement('div');
            pairedBoundaryItem.className = 'legend-item';
            pairedBoundaryItem.innerHTML = `
                <div class="legend-color" style="background-color: #333; width: 20px; height: 3px; border-radius: 0;"></div>
                <span>Paired Boundaries (Darker Region Color)</span>
            `;
            legendDiv.appendChild(pairedBoundaryItem);

            const unpairedBoundaryItem = document.createElement('div');
            unpairedBoundaryItem.className = 'legend-item';
            unpairedBoundaryItem.innerHTML = `
                <div class="legend-color" style="background-color: #000000; width: 20px; height: 2px; border-radius: 0;"></div>
                <span>Unpaired Boundaries (Black)</span>
            `;
            legendDiv.appendChild(unpairedBoundaryItem);
        }

        function drawHierarchicalVisualization(imagePoints, voronoiData) {
            // If we have adjacency data, use the adjacency visualization instead
            if (currentAdjacencyData) {
                drawAdjacencyVisualization(imagePoints, voronoiData, currentAdjacencyData);
                return;
            }

            // Original hierarchical visualization code
            const canvas = document.getElementById('hierarchical-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const cells = voronoiData.cells || [];
            const legendDiv = document.getElementById('region-legend');
            
            // Clear legend
            legendDiv.innerHTML = '';

            // Find min/max for scaling
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            imagePoints.forEach(pt => {
                if (pt.x < minX) minX = pt.x;
                if (pt.x > maxX) maxX = pt.x;
                if (pt.y < minY) minY = pt.y;
                if (pt.y > maxY) maxY = pt.y;
            });

            const pad = 40;
            const plotW = canvas.width - pad * 2;
            const plotH = canvas.height - pad * 2;

            // Draw Voronoi regions (original colors)
            cells.forEach((cell, idx) => {
                const color = regionColors[idx % regionColors.length];
                
                if (cell.vertices && cell.vertices.length > 2) {
                    ctx.beginPath();
                    
                    // Scale vertices to canvas
                    const scaledVertices = cell.vertices.map(v => ({
                        x: pad + ((v[0] - minX) / (maxX - minX)) * plotW,
                        y: pad + ((v[1] - minY) / (maxY - minY)) * plotH
                    }));
                    
                    // Draw region polygon
                    ctx.moveTo(scaledVertices[0].x, scaledVertices[0].y);
                    for (let i = 1; i < scaledVertices.length; i++) {
                        ctx.lineTo(scaledVertices[i].x, scaledVertices[i].y);
                    }
                    ctx.closePath();
                    
                    // Fill with light color
                    ctx.fillStyle = color + '20'; // Add transparency
                    ctx.fill();
                    
                    // Stroke with darker color
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }

                // Draw region centroid
                if (cell.centroid && cell.centroid.length === 2) {
                    const cx = pad + ((cell.centroid[0] - minX) / (maxX - minX)) * plotW;
                    const cy = pad + ((cell.centroid[1] - minY) / (maxY - minY)) * plotH;
                    
                    // Draw centroid as a larger circle
                    ctx.beginPath();
                    ctx.arc(cx, cy, 8, 0, 2 * Math.PI);
                    ctx.fillStyle = color;
                    ctx.fill();
                    ctx.strokeStyle = "#000";
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Add white center dot
                    ctx.beginPath();
                    ctx.arc(cx, cy, 3, 0, 2 * Math.PI);
                    ctx.fillStyle = "#fff";
                    ctx.fill();

                    // Draw region label
                    ctx.font = "12px Arial";
                    ctx.fillStyle = "#000";
                    ctx.textAlign = "center";
                    ctx.fillText(cell.clusterLabel || `R${cell.id}`, cx, cy - 12);
                }

                // Add to legend
                const legendItem = document.createElement('div');
                legendItem.className = 'legend-item';
                legendItem.innerHTML = `
                    <div class="legend-color" style="background-color: ${color}"></div>
                    <span>${cell.clusterLabel || `Region ${cell.id + 1}`} (${cell.pointCount})</span>
                `;
                legendDiv.appendChild(legendItem);
            });

            // Draw image points on top
            imagePoints.forEach(pt => {
                const x = pad + ((pt.x - minX) / (maxX - minX)) * plotW;
                const y = pad + ((pt.y - minY) / (maxY - minY)) * plotH;
                
                // Get region color if available
                let pointColor = "#333";
                if (pt.hierarchicalInfo && pt.hierarchicalInfo.regionId !== undefined) {
                    pointColor = regionColors[pt.hierarchicalInfo.regionId % regionColors.length];
                }
                
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, 2 * Math.PI);
                ctx.fillStyle = pointColor;
                ctx.fill();
                ctx.strokeStyle = "#fff";
                ctx.lineWidth = 1;
                ctx.stroke();
            });

            // Add hover functionality (same as original)
            canvas.onmousemove = function(e) {
                const rect = canvas.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;
                
                let hoverIdx = null;
                imagePoints.forEach((pt, i) => {
                    const x = pad + ((pt.x - minX) / (maxX - minX)) * plotW;
                    const y = pad + ((pt.y - minY) / (maxY - minY)) * plotH;
                    if (Math.hypot(mx - x, my - y) < 8) {
                        hoverIdx = i;
                    }
                });
                
                // Redraw to clear previous tooltip
                drawHierarchicalVisualization(imagePoints, voronoiData);
                
                if (hoverIdx !== null) {
                    const pt = imagePoints[hoverIdx];
                    // Draw tooltip
                    ctx.save();
                    ctx.font = "12px Arial";
                    ctx.textAlign = "left";
                    
                    let label = pt.artworkData?.value || pt.entryId;
                    let artist = "";
                    try {
                        const names = JSON.parse(pt.artworkData?.artist_names || "[]");
                        artist = Array.isArray(names) ? names.join(", ") : names;
                    } catch { 
                        artist = pt.artworkData?.artist_names || "Unknown";
                    }
                    
                    let region = "";
                    if (pt.hierarchicalInfo) {
                        region = pt.hierarchicalInfo.regionLabel || `Region ${pt.hierarchicalInfo.regionId + 1}`;
                    }
                    
                    const text = `${label}\n${artist}\n${region}`;
                    const lines = text.split('\n');
                    const tw = Math.max(...lines.map(l => ctx.measureText(l).width));
                    const th = lines.length * 16 + 10;
                    
                    let tx = mx + 10, ty = my - th - 10;
                    if (tx + tw + 20 > canvas.width) tx = canvas.width - tw - 20;
                    if (ty < 0) ty = my + 10;
                    
                    // Draw background rectangle
                    ctx.beginPath();
                    ctx.rect(tx, ty, tw + 20, th);
                    ctx.fillStyle = "#222";
                    ctx.globalAlpha = 0.92;
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                    ctx.strokeStyle = "#fff";
                    ctx.stroke();
                    
                    // Draw text
                    ctx.fillStyle = "#fff";
                    ctx.textAlign = "left";
                    lines.forEach((l, i) => {
                        ctx.fillText(l, tx + 10, ty + 18 + i * 16);
                    });
                    ctx.restore();
                }
            };

            canvas.onmouseleave = function() {
                drawHierarchicalVisualization(imagePoints, voronoiData);
            };
        }

        function clearVisualization() {
            const canvas = document.getElementById('hierarchical-canvas');
            if (canvas) {
                canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
            }
            const legendDiv = document.getElementById('region-legend');
            if (legendDiv) {
                legendDiv.innerHTML = '';
            }
            // Reset adjacency data
            currentAdjacencyData = null;
            document.getElementById('adjacencyBtn').disabled = true;
            
            // Reset merge button to original state
            const mergeBtn = document.getElementById('mergeBtn');
            mergeBtn.disabled = true;
            mergeBtn.innerHTML = 'üîó Merge Paired Regions';
        }

        // Test on Enter key
        document.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !document.getElementById('generateBtn').disabled) {
                generateHierarchicalMap();
            }
        });

        // Set default values on load
        window.onload = function() {
            console.log('Hierarchical Map API Check page loaded');
        };
    </script>
</body>
</html>
