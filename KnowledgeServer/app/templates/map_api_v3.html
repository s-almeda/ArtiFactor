<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Map API v3 Check</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/map_api_v3.css') }}">
</head>
<body>
    <div class="container">
        <h1>üé® Map API Check v3</h1>
        
        <div class="parameters-section">
        <div class="parameters-section">
            <div class="section-title">Padding</div>
            <div class="param-group">
                <div class="param-item">
                    <label for="paddingFactor">padding_factor <span class="api-key-label">(Cluster UMAP padding, 0.0-0.5 typical)</span></label>
                    <input type="number" id="paddingFactor" value="0.1" step="0.01" min="0" max="0.5">
                </div>
            </div>
        </div>
            <div class="section-title">Salient Keywords</div>
            <div class="param-group">
                <div class="param-item">
                    <label for="numKeywords">Number of Keywords</label>
                    <input type="number" id="numKeywords" value="50" min="1" max="200">
                </div>
            </div>
        </div>

        <div class="parameters-section">
            <div class="section-title">Embedding Weights</div>
            <div class="param-group">
                <div class="param-item">
                    <label for="clipWeight">clip <span class="api-key-label">(CLIP visual)</span></label>
                    <input type="number" id="clipWeight" value="0.3" step="0.1" min="0" max="1">
                </div>
                <div class="param-item">
                    <label for="resnetWeight">resnet <span class="api-key-label">(ResNet visual)</span></label>
                    <input type="number" id="resnetWeight" value="0.5" step="0.1" min="0" max="1">
                </div>
                <div class="param-item">
                    <label for="keywordSemanticWeight">keyword_semantic <span class="api-key-label">(Text semantic)</span></label>
                    <input type="number" id="keywordSemanticWeight" value="0.2" step="0.1" min="0" max="1">
                </div>
                <div class="param-item">
                    <label for="keywordBiasWeight">keyword_bias <span class="api-key-label">(Main keyword bias)</span></label>
                    <input type="number" id="keywordBiasWeight" value="0.6" step="0.1" min="0" max="1">
                </div>
                <div class="param-item">
                    <label for="debugWeight">debug <span class="api-key-label">(Debug logging)</span></label>
                    <input type="checkbox" id="debugWeight" checked>
                </div>
            </div>
        </div>

        <div class="parameters-section">
            <div class="section-title">UMAP Parameters</div>
            <div class="param-group">
                <div class="param-item">
                    <label for="minDist">min_dist</label>
                    <input type="number" id="minDist" value="0.9" step="0.1" min="0" max="1">
                </div>
                <div class="param-item">
                    <label for="useParallel">parallel <span class="api-key-label">(Fast but non-deterministic)</span></label>
                    <input type="checkbox" id="useParallel" checked>
                </div>
                <div class="param-item">
                    <label for="randomState">random_state <span class="api-key-label">(Only used if parallel unchecked)</span></label>
                    <input type="number" id="randomState" value="42" placeholder="42">
                </div>
            </div>
        </div>

        <div class="parameters-section">
            <div class="section-title">Clustering Parameters</div>
            <div class="param-group">
                <div class="param-item">
                    <label for="nClusters">Number of Clusters <span class="api-key-label">(leave empty for auto)</span></label>
                    <input type="number" id="nClusters" placeholder="Auto" min="2" max="50">
                </div>
            </div>
        </div>

        <div class="parameters-section">
            <div class="section-title">Compression Parameters</div>
            <div class="param-group">
                <div class="param-item">
                    <label for="thresholdPercentile">Threshold Percentile</label>
                    <input type="number" id="thresholdPercentile" value="90" min="50" max="99">
                </div>
                <div class="param-item">
                    <label for="compressionFactor">Compression Factor</label>
                    <input type="number" id="compressionFactor" value="0.3" step="0.1" min="0.1" max="1">
                </div>
            </div>
        </div>

        <button onclick="generateMap()" id="generateButton">Generate Map üó∫Ô∏è</button>
        
        <div id="status" class="status" style="display: none;"></div>
        <div id="timer" class="timer" style="display: none;"></div>
        
        <!-- Visualization container -->
        <div id="visualizationContainer" class="visualization-container" style="display: none;">
            <h2>Hierarchical Artwork Map</h2>
            <canvas id="mapCanvas" width="1000" height="800"></canvas>
            
            <div class="tooltip" id="tooltip"></div>
            <div class="legend" id="legend"></div>
            
            <h2>Cluster Details</h2>
            <div id="clusterInfo" class="cluster-info"></div>
            
            <span class="toggle-details" onclick="toggleResponseDetails()">Show/Hide Raw Response</span>
            <div id="responseDetails" style="display: none;"></div>
        </div>
    </div>

    <script>
        let globalData = null;
        let selectedCluster = null;
        let timerInterval = null;
        let startTime = null;
        let currentJobId = null;
        
        // Color palette for clusters
        const colorPalette = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57',
            '#48C9B0', '#9B59B6', '#E74C3C', '#3498DB', '#1ABC9C',
            '#F39C12', '#D35400', '#7F8C8D', '#2C3E50', '#16A085',
            '#E67E22', '#8E44AD', '#27AE60', '#C0392B', '#2980B9'
        ];
        
        function getColorForCluster(index) {
            return colorPalette[index % colorPalette.length];
        }

        async function generateMap() {
            console.log('generateMap() called');
            const status = document.getElementById('status');
            const timer = document.getElementById('timer');
            const visualizationContainer = document.getElementById('visualizationContainer');
            const generateButton = document.getElementById('generateButton');

            // Build parameters
            const params = {
                debug: document.getElementById('debugWeight').checked,
                numKeywords: parseInt(document.getElementById('numKeywords').value),
                weights: {
                    clip: parseFloat(document.getElementById('clipWeight').value),
                    resnet: parseFloat(document.getElementById('resnetWeight').value),
                    keyword_semantic: parseFloat(document.getElementById('keywordSemanticWeight').value),
                    keyword_bias: parseFloat(document.getElementById('keywordBiasWeight').value),
                    debug: document.getElementById('debugWeight').checked
                },
                umap: {
                    min_dist: parseFloat(document.getElementById('minDist').value),
                    parallel: document.getElementById('useParallel').checked
                },
                compression: {
                    threshold_percentile: parseInt(document.getElementById('thresholdPercentile').value),
                    compression_factor: parseFloat(document.getElementById('compressionFactor').value)
                },
                padding_factor: parseFloat(document.getElementById('paddingFactor').value)
            };

            // Only add random_state if parallel is false
            if (!params.umap.parallel) {
                params.umap.random_state = parseInt(document.getElementById('randomState').value) || 42;
            }

            // Add n_clusters if specified
            const nClustersInput = document.getElementById('nClusters').value;
            if (nClustersInput && nClustersInput.trim() !== '') {
                params.n_clusters = parseInt(nClustersInput);
            }

            // Disable button and show status
            generateButton.disabled = true;
            generateButton.textContent = 'Processing...';
            status.style.display = 'block';
            timer.style.display = 'block';
            timer.textContent = '';
            visualizationContainer.style.display = 'none';

            try {
                // Submit job
                status.textContent = 'Submitting job...';
                status.className = 'status loading';
                
                const jobResponse = await fetch('/submit_map_job', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(params)
                });

                const jobData = await jobResponse.json();
                console.log('Job submission response:', jobData);
                

                if (!jobResponse.ok) {
                    console.error('Job submission failed:', jobData);
                    throw new Error(jobData.error || 'Failed to submit job');
                }

                // Check if result was cached

                if (jobData.result) {
                    console.log('Loaded from cache:', jobData.result);
                    status.textContent = 'Loaded from cache!';
                    status.className = 'status success';
                    showResults(jobData.result);
                    return;
                }

                // Start polling for job status
                currentJobId = jobData.job_id;
                startTime = Date.now();
                
                // Start timer
                timerInterval = setInterval(() => {
                    const elapsed = Date.now() - startTime;
                    // Show ms with 1 decimal (e.g. 5.3s)
                    const seconds = (elapsed / 1000).toFixed(3);
                    timer.textContent = `${seconds}s elapsed`;
                }, 50);

                console.log('Polling job status for jobId:', currentJobId);
                pollJobStatus(currentJobId);
                
            } catch (error) {
                resetUI();
                status.textContent = `Error: ${error.message}`;
                status.className = 'status error';
            }
        }

        async function pollJobStatus(jobId) {
            const status = document.getElementById('status');
            const timer = document.getElementById('timer');
            try {
                console.log('Polling job status for jobId:', jobId);
                const response = await fetch(`/job_status/${jobId}`);
                const statusData = await response.json();
                console.log('Job status response:', statusData);
                
                if (!response.ok) {
                    console.error('Job status fetch failed:', statusData);
                    throw new Error(statusData.error || 'Failed to get job status');
                }

                // Update status message (timer will add elapsed time)
                status.textContent = statusData.message || 'Processing...';
                
                if (statusData.status === 'completed') {
                    clearInterval(timerInterval);
                    timer.textContent = '';
                    timer.style.display = 'none';
                    console.log('Job completed, fetching result for cache_key:', statusData.cache_key);
                    // Get the result
                    const resultResponse = await fetch(`/get_result/${statusData.cache_key}`);
                    const result = await resultResponse.json();
                    console.log('Result response:', result);
                    if (resultResponse.ok) {
                        const elapsed = (Date.now() - startTime) / 1000;
                        status.textContent = `Completed in ${elapsed.toFixed(3)}s!`;
                        status.className = 'status success';
                        showResults(result);
                    } else {
                        console.error('Failed to get result:', result);
                        throw new Error(result.error || 'Failed to get result');
                    }
                } else if (statusData.status === 'failed') {
                    clearInterval(timerInterval);
                    timer.textContent = '';
                    timer.style.display = 'none';
                    resetUI();
                    status.textContent = `Job failed: ${statusData.error || 'Unknown error'}`;
                    status.className = 'status error';
                } else {
                    // Still processing, poll again
                    setTimeout(() => pollJobStatus(jobId), 2000);
                }
                
            } catch (error) {
                clearInterval(timerInterval);
                resetUI();
                console.error('Error in pollJobStatus:', error);
                status.textContent = `Error checking status: ${error.message}`;
                status.className = 'status error';
            }
        }

        function showResults(data) {
            resetUI();
            globalData = data;
            
            // Show visualization
            document.getElementById('visualizationContainer').style.display = 'block';
            document.getElementById('responseDetails').textContent = JSON.stringify(data, null, 2);
            
            // Draw map and create UI
            drawHierarchicalMap(data);
            createLegend(data);
            if (data.clusters && data.clusters.length > 0) {
                showClusterInfo(data.clusters[0]); // Show first cluster by default
            }
        }

        function resetUI() {
            const generateButton = document.getElementById('generateButton');
            const timer = document.getElementById('timer');
            generateButton.disabled = false;
            generateButton.textContent = 'Generate Map üó∫Ô∏è';
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            timer.textContent = '';
            timer.style.display = 'none';
            currentJobId = null;
        }


        

        function drawHierarchicalMap(data) {
            const canvas = document.getElementById('mapCanvas');
            const ctx = canvas.getContext('2d');
            const tooltip = document.getElementById('tooltip');
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw Voronoi cells first (background)
            data.clusters.forEach((cluster, index) => {
                const color = getColorForCluster(index);
                
                // Draw Voronoi cell
                if (cluster.voronoi_vertices && cluster.voronoi_vertices.length > 0) {
                    ctx.beginPath();
                    const firstVertex = cluster.voronoi_vertices[0];
                    ctx.moveTo(firstVertex[0] * canvas.width, firstVertex[1] * canvas.height);
                    
                    cluster.voronoi_vertices.forEach(vertex => {
                        ctx.lineTo(vertex[0] * canvas.width, vertex[1] * canvas.height);
                    });
                    ctx.closePath();
                    
                    // Fill with very transparent color
                    ctx.fillStyle = color + '15';
                    ctx.fill();
                    
                    // Stroke with semi-transparent color
                    ctx.strokeStyle = color + '60';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            });
            
            // Draw artworks within each cluster
            data.clusters.forEach((cluster, clusterIndex) => {
                const color = getColorForCluster(clusterIndex);
                
                cluster.artworks_map.forEach(artwork => {
                    const x = artwork.coords.x * canvas.width;
                    const y = artwork.coords.y * canvas.height;
                    
                    // Draw artwork point
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, 2 * Math.PI);
                    ctx.fillStyle = color;
                    ctx.fill();
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                });
                
                // Draw cluster centroid
                const cx = cluster.centroid.x * canvas.width;
                const cy = cluster.centroid.y * canvas.height;
                
                ctx.beginPath();
                ctx.arc(cx, cy, 8, 0, 2 * Math.PI);
                ctx.fillStyle = color;
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw cluster label
                ctx.fillStyle = '#000';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(cluster.cluster_label, cx, cy - 12);
            });
            
            // Mouse hover handler
            canvas.onmousemove = function(e) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                let foundArtwork = null;
                let foundCluster = null;
                const threshold = 10;
                
                // Find nearest artwork
                data.clusters.forEach(cluster => {
                    cluster.artworks_map.forEach(artworkMap => {
                        const x = artworkMap.coords.x * canvas.width;
                        const y = artworkMap.coords.y * canvas.height;
                        const distance = Math.sqrt(Math.pow(x - mouseX, 2) + Math.pow(y - mouseY, 2));
                        
                        if (distance < threshold) {
                            foundArtwork = data.artworks[artworkMap.id];
                            foundCluster = cluster;
                        }
                    });
                });
                
                if (foundArtwork) {
                    tooltip.innerHTML = `
                        <div class="title">${foundArtwork.title}</div>
                        <div class="artist">${foundArtwork.artist}</div>
                        <div class="keyword">${foundCluster.cluster_label}</div>
                        ${foundArtwork.year ? `<div class="year">${foundArtwork.year}</div>` : ''}
                    `;
                    tooltip.style.display = 'block';
                    tooltip.style.left = (e.pageX + 10) + 'px';
                    tooltip.style.top = (e.pageY - 10) + 'px';
                    canvas.style.cursor = 'pointer';
                } else {
                    tooltip.style.display = 'none';
                    canvas.style.cursor = 'crosshair';
                }
            };
            
            canvas.onmouseleave = function() {
                tooltip.style.display = 'none';
            };
            
            // Click handler for cluster selection
            canvas.onclick = function(e) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Find which cluster was clicked
                data.clusters.forEach((cluster, index) => {
                    const cx = cluster.centroid.x * canvas.width;
                    const cy = cluster.centroid.y * canvas.height;
                    const distance = Math.sqrt(Math.pow(cx - mouseX, 2) + Math.pow(cy - mouseY, 2));
                    
                    if (distance < 20) {
                        selectedCluster = index;
                        showClusterInfo(cluster);
                        highlightCluster(data, index);
                    }
                });
            };
        }

        function createLegend(data) {
            const legend = document.getElementById('legend');
            legend.innerHTML = '<h3>Clusters</h3>';
            
            data.clusters.forEach((cluster, index) => {
                const color = getColorForCluster(index);
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `
                    <div class="legend-color" style="background-color: ${color}"></div>
                    <div class="legend-text">${cluster.cluster_label}</div>
                    <div class="legend-count">${cluster.artworks_map.length} artworks</div>
                `;
                
                // Click handler for highlighting
                item.onclick = function() {
                    selectedCluster = index;
                    showClusterInfo(cluster);
                    highlightCluster(data, index);
                };
                
                legend.appendChild(item);
            });
        }
        
        function highlightCluster(data, clusterIndex) {
            const canvas = document.getElementById('mapCanvas');
            drawHierarchicalMap(data); // Redraw
            
            // Add highlight effect
            const ctx = canvas.getContext('2d');
            const cluster = data.clusters[clusterIndex];
            const color = getColorForCluster(clusterIndex);
            
            // Highlight Voronoi cell
            if (cluster.voronoi_vertices && cluster.voronoi_vertices.length > 0) {
                ctx.beginPath();
                const firstVertex = cluster.voronoi_vertices[0];
                ctx.moveTo(firstVertex[0] * canvas.width, firstVertex[1] * canvas.height);
                
                cluster.voronoi_vertices.forEach(vertex => {
                    ctx.lineTo(vertex[0] * canvas.width, vertex[1] * canvas.height);
                });
                ctx.closePath();
                
                ctx.strokeStyle = color;
                ctx.lineWidth = 4;
                ctx.stroke();
            }
        }
        
        function showClusterInfo(cluster) {
            const info = document.getElementById('clusterInfo');
            const repArtwork = globalData.artworks[cluster.representative_artwork_id];
            
            info.innerHTML = `
                <h3>${cluster.cluster_label}</h3>
                <p><strong>Artworks:</strong> ${cluster.artworks_map.length}</p>
                <p><strong>Representative:</strong> ${repArtwork.title} by ${repArtwork.artist}</p>
                <div class="artwork-list">
                    <h4>Sample Artworks:</h4>
                    ${cluster.artworks_map.slice(0, 5).map(artworkMap => {
                        const artwork = globalData.artworks[artworkMap.id];
                        return `<div class="artwork-item">‚Ä¢ ${artwork.title} - ${artwork.artist}</div>`;
                    }).join('')}
                    ${cluster.artworks_map.length > 5 ? `<div class="artwork-item">... and ${cluster.artworks_map.length - 5} more</div>` : ''}
                </div>
            `;
        }
        
        function toggleResponseDetails() {
            const details = document.getElementById('responseDetails');
            details.style.display = details.style.display === 'none' ? 'block' : 'none';
        }
    </script>
    
</body>
</html>