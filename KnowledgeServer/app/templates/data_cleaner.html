<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Database Data Cleaner</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/admin_styles.css') }}">
</head>
<body>
    <!-- Password Modal -->
    <div id="passwordModal" class="modal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5);">
        <div class="modal-content" style="background-color: #fefefe; margin: 15% auto; padding: 20px; border: 1px solid #888; width: 400px; border-radius: 8px;">
            <h3>Enter Admin Password</h3>
            <p>Please enter the admin password to access the database cleaning functionality:</p>
            <input type="password" id="passwordInput" placeholder="Admin password" style="width: 100%; padding: 8px; margin: 10px 0; border: 1px solid #ddd; border-radius: 4px;">
            <div style="margin-top: 15px;">
                <button id="passwordSubmit" class="btn">Submit</button>
                <button id="passwordCancel" class="btn-secondary" style="margin-left: 10px;">Cancel</button>
            </div>
            <div id="passwordError" style="color: red; margin-top: 10px; display: none;"></div>
        </div>
    </div>

    <div class="data-cleaner-container" id="main-content" style="display: none;">
        <h1>üßπ Database Data Cleaner</h1>
        <p>Identify and fix data integrity issues in your database</p>

        <!-- Database Stats Section -->
        <div class="cleaner-section">
            <h3>üìä Database Overview</h3>
            <div id="database-stats">
                <button type="button" class="btn" onclick="loadDatabaseStats()">Load Database Stats</button>
                <div id="stats-display"></div>
            </div>
        </div>

        <!-- Malformed JSON Section -->
        <div class="cleaner-section">
            <h3>üîß Malformed JSON Repair</h3>
            <p>Find and fix Python-style lists that should be proper JSON</p>
            
            <div class="action-buttons">
                <button type="button" class="btn" onclick="checkMalformedJson()" id="json-check-btn">
                    üîç Check for Malformed JSON
                </button>
                <div class="loading" id="json-check-loading">Scanning for malformed JSON...</div>
            </div>

            <!-- JSON Results Section -->
            <div id="json-results" style="display: none;">
                <div class="results-header">
                    <h4 id="json-results-title"></h4>
                    <div id="json-results-summary"></div>
                </div>

                <!-- JSON Fix Button -->
                <div id="json-fix-section" style="display: none;">
                    <button type="button" class="btn btn-warning" onclick="fixMalformedJson()" id="json-fix-btn">
                        üîß Convert to Proper JSON
                    </button>
                    <div class="loading" id="json-fix-loading">Converting to JSON...</div>
                    <p class="warning-text">‚ö†Ô∏è This will convert Python-style lists to proper JSON format.</p>
                </div>

                <!-- Malformed Entries List -->
                <div id="malformed-entries-list"></div>
            </div>

            <!-- JSON Success Message -->
            <div id="json-fix-success" class="success-message" style="display: none;"></div>
        </div>


        <!-- Artists Without Images Section -->
        <div class="cleaner-section">
            <h3>üé® Artists Without Images</h3>
            <p>Find artists without images, search for related artworks, and update or remove them</p>
            
            <div class="action-buttons">
                <button type="button" class="btn" onclick="checkArtistsWithoutImages()" id="artists-check-btn">
                    üîç Check for Artists Without Images
                </button>
                <div class="loading" id="artists-check-loading">Scanning for artists without images...</div>
            </div>

            <!-- Artists Results Section -->
            <div id="artists-results" style="display: none;">
                <div class="results-header">
                    <h4 id="artists-results-title"></h4>
                    <div id="artists-results-summary"></div>
                </div>

                <!-- Search and Execute Buttons -->
                <div id="artists-action-section" style="display: none;">
                    <button type="button" class="btn btn-info" onclick="searchAllRelatedArtworks()" id="search-all-btn">
                        üîç Search for Related Artworks (All Artists)
                    </button>
                    <div class="loading" id="search-all-loading">Searching for related artworks for all artists...</div>
                    <p class="info-text">‚ö†Ô∏è This will search for artworks that reference these artists in their relatedKeywordIds.</p>
                </div>

                <!-- Search Results Section -->
                <div id="search-results-section" style="display: none;">
                    <div class="results-header">
                        <h4 id="search-results-title"></h4>
                        <div id="search-results-summary"></div>
                    </div>
                    
                    <div id="execute-action-section" style="display: none;">
                        <button type="button" class="btn btn-warning" onclick="executeArtistUpdates()" id="execute-updates-btn">
                            ‚ö° Execute Updates
                        </button>
                        <div class="loading" id="execute-loading">Updating database...</div>
                        <p class="warning-text">‚ö†Ô∏è This will add found images to artists' image lists and remove artists with no matches.</p>
                    </div>
                    
                    <div id="search-results-details"></div>
                </div>

                <!-- Original Remove All Button (fallback) -->
                <div id="artists-remove-section" style="display: none;">
                    <button type="button" class="btn btn-danger" onclick="removeArtistsWithoutImages()" id="artists-remove-btn">
                        üóëÔ∏è Remove All Artists Without Images
                    </button>
                    <div class="loading" id="artists-remove-loading">Removing artists...</div>
                    <p class="warning-text">‚ö†Ô∏è This will permanently delete these artist entries from your database.</p>
                </div>

                <!-- Artists List -->
                <div id="artists-list"></div>
            </div>

            <!-- Artists Success Message -->
            <div id="artists-success" class="success-message" style="display: none;"></div>
        </div>

        <!-- Orphaned Image References Section -->
        <div class="cleaner-section">
            <h3>üîó Orphaned Image References</h3>
            <p>Find text entries that reference non-existent image IDs</p>
            
            <div class="action-buttons">
                <button type="button" class="btn" onclick="checkOrphanedImages()" id="check-btn">
                    üîç Check for Orphaned References
                </button>
                <div class="loading" id="check-loading">Checking database...</div>
            </div>

            <!-- Results Section -->
            <div id="orphaned-results" style="display: none;">
                <div class="results-header">
                    <h4 id="results-title"></h4>
                    <div id="results-summary"></div>
                </div>

                <!-- Fix Button (appears only when issues found) -->
                <div id="fix-section" style="display: none;">
                    <button type="button" class="btn btn-danger" onclick="fixOrphanedImages()" id="fix-btn">
                        üîß Fix All Orphaned References
                    </button>
                    <div class="loading" id="fix-loading">Fixing entries...</div>
                    <p class="warning-text">‚ö†Ô∏è This will permanently remove invalid image references from your database.</p>
                </div>

                <!-- Faulty Entries List -->
                <div id="faulty-entries-list"></div>
            </div>

            <!-- Success Message -->
            <div id="fix-success" class="success-message" style="display: none;"></div>
        </div>


        <!-- Artists <-> Images Integrity Check Section -->
        <div class="cleaner-section">
            <h3>ÔøΩ Artists ‚Üî Images Integrity Check</h3>
            <p>Check that all image IDs in artist's images list exist and are properly linked back to the artist</p>
            
            <div class="action-buttons">
                <button type="button" class="btn" onclick="checkArtistImageIntegrity()" id="integrity-check-btn">
                    üîç Check Artist-Image Integrity
                </button>
                <div class="loading" id="integrity-check-loading">Checking artist-image relationships...</div>
            </div>

            <!-- Integrity Results Section -->
            <div id="integrity-results" style="display: none;">
                <div class="results-header">
                    <h4 id="integrity-results-title"></h4>
                    <div id="integrity-results-summary"></div>
                </div>

                <!-- Integrity Fix Button -->
                <div id="integrity-fix-section" style="display: none;">
                    <button type="button" class="btn btn-warning" onclick="fixArtistImageIntegrity()" id="integrity-fix-btn">
                        ÔøΩ Fix All Integrity Issues
                    </button>
                    <div class="loading" id="integrity-fix-loading">Fixing integrity issues...</div>
                    <p class="warning-text">‚ö†Ô∏è This will fix missing references and remove invalid image IDs from artist lists.</p>
                </div>

                <!-- Integrity Issues List -->
                <div id="integrity-issues-list"></div>
            </div>

            <!-- Integrity Success Message -->
            <div id="integrity-fix-success" class="success-message" style="display: none;"></div>
        </div>

        <!-- Related Keywords Integrity Section -->
        <div class="cleaner-section">
            <h3>üîó Related Keywords Integrity</h3>
            <p>Check and fix RelatedKeywordIds references and ensure RelatedKeywordStrings match</p>
            
            <div class="action-buttons">
                <button type="button" class="btn" onclick="checkRelatedKeywords()" id="keywords-check-btn">
                    üîç Check Related Keywords
                </button>
                <div class="loading" id="keywords-check-loading">Checking keyword references...</div>
            </div>

            <!-- Keywords Results Section -->
            <div id="keywords-results" style="display: none;">
                <div class="results-header">
                    <h4 id="keywords-results-title"></h4>
                    <div id="keywords-results-summary"></div>
                </div>

                <!-- Keywords Fix Button -->
                <div id="keywords-fix-section" style="display: none;">
                    <button type="button" class="btn btn-warning" onclick="fixRelatedKeywords()" id="keywords-fix-btn">
                        üîß Fix All Keyword Issues
                    </button>
                    <div class="loading" id="keywords-fix-loading">Fixing keyword references...</div>
                    <p class="warning-text">‚ö†Ô∏è This will remove invalid IDs and rebuild the strings list from valid references.</p>
                </div>

                <!-- Keywords Issues List -->
                <div id="keywords-issues-list"></div>
            </div>

            <!-- Keywords Success Message -->
            <div id="keywords-success" class="success-message" style="display: none;"></div>
        </div>





        <!-- Future Cleaning Options -->
        <div class="cleaner-section">
            <h3>üöÄ More Cleaning Options</h3>
            <p>Additional data cleaning features coming soon...</p>
            <div class="placeholder-buttons">
                <button type="button" class="btn btn-secondary disabled" disabled>Check Orphaned Text References</button>
                <button type="button" class="btn btn-secondary disabled" disabled>Validate JSON Formatting</button>
                <button type="button" class="btn btn-secondary disabled" disabled>Find Duplicate Entries</button>
            </div>
        </div>












    </div>









    <script>
        let adminPassword = null;
        let currentFaultyEntries = [];
        let currentMalformedEntries = [];

        document.addEventListener('DOMContentLoaded', function() {
            // Check if password is stored in localStorage
            const storedPassword = localStorage.getItem('staging_admin_password');
            if (storedPassword) {
                adminPassword = storedPassword;
                showMainContent();
                loadDatabaseStats();
            } else {
                showPasswordModal();
            }
        });

        function showPasswordModal() {
            document.getElementById('passwordModal').style.display = 'block';
            document.getElementById('passwordInput').focus();
            
            // Handle password submission
            document.getElementById('passwordSubmit').onclick = async function() {
                const password = document.getElementById('passwordInput').value;
                
                if (!password) {
                    showPasswordError('Please enter a password');
                    return;
                }
                
                const isValid = await validatePassword(password);
                if (isValid) {
                    adminPassword = password;
                    localStorage.setItem('staging_admin_password', password);
                    document.getElementById('passwordModal').style.display = 'none';
                    showMainContent();
                    loadDatabaseStats();
                } else {
                    showPasswordError('Invalid password');
                }
            };
            
            document.getElementById('passwordCancel').onclick = function() {
                window.location.href = '/';
            };
            
            // Handle Enter key
            document.getElementById('passwordInput').onkeypress = function(e) {
                if (e.key === 'Enter') {
                    document.getElementById('passwordSubmit').click();
                }
            };
        }

        function showPasswordError(message) {
            const errorDiv = document.getElementById('passwordError');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        async function validatePassword(password) {
            try {
            // Call a dedicated endpoint that checks the password against the environment variable
            const response = await fetch('/validate_admin_password', {
                method: 'POST',
                headers: {
                'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                password: password
                })
            });

            const result = await response.json();
            // The backend should return { success: true } if password matches
            return !!result.success;
            } catch (error) {
            return false;
            }
        }


        function showMainContent() {
            document.getElementById('main-content').style.display = 'block';
        }

        // Clear password function (for debugging)
        function clearPassword() {
            localStorage.removeItem('staging_admin_password');
            location.reload();
        }

        function loadDatabaseStats() {
            fetch('/get_database_stats')
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    const statsHtml = `
                        <div class="stats-grid">
                            <div class="stat-card">
                                <div class="stat-number">${data.stats.total_text_entries}</div>
                                <div class="stat-label">Text Entries</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-number">${data.stats.total_image_entries}</div>
                                <div class="stat-label">Image Entries</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-number">${data.stats.text_entries_with_images}</div>
                                <div class="stat-label">Text w/ Image Refs</div>
                            </div>
                        </div>
                    `;
                    document.getElementById('stats-display').innerHTML = statsHtml;
                } else {
                    document.getElementById('stats-display').innerHTML = `<div class="error">Error: ${data.error}</div>`;
                }
            })
            .catch(error => {
                console.error('Error:', error);
                document.getElementById('stats-display').innerHTML = `<div class="error">Failed to load stats</div>`;
            });
        }

        function checkMalformedJson() {
            const checkBtn = document.getElementById('json-check-btn');
            const loading = document.getElementById('json-check-loading');
            const resultsDiv = document.getElementById('json-results');
            
            checkBtn.disabled = true;
            loading.style.display = 'block';
            resultsDiv.style.display = 'none';
            
            fetch('/check_malformed_json', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    currentMalformedEntries = data.malformed_entries;
                    displayMalformedResults(data);
                } else {
                    alert('Error checking malformed JSON: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Failed to check malformed JSON');
            })
            .finally(() => {
                checkBtn.disabled = false;
                loading.style.display = 'none';
            });
        }

        function displayMalformedResults(data) {
            const resultsDiv = document.getElementById('json-results');
            const titleEl = document.getElementById('json-results-title');
            const summaryEl = document.getElementById('json-results-summary');
            const fixSection = document.getElementById('json-fix-section');
            const entriesList = document.getElementById('malformed-entries-list');
            
            if (data.total_malformed === 0) {
                titleEl.textContent = '‚úÖ All JSON is Properly Formatted';
                summaryEl.innerHTML = '<div class="success">No malformed JSON found!</div>';
                fixSection.style.display = 'none';
                entriesList.innerHTML = '';
            } else {
                titleEl.textContent = `‚ö†Ô∏è Found ${data.total_malformed} Entries with Malformed JSON`;
                
                const fixableCount = data.malformed_entries.filter(e => e.converted_json !== null).length;
                summaryEl.innerHTML = `
                    <div class="warning">
                        <strong>${data.total_malformed}</strong> entries have malformed JSON<br>
                        <strong>${fixableCount}</strong> can be automatically converted to proper JSON
                    </div>
                `;
                
                if (fixableCount > 0) {
                    fixSection.style.display = 'block';
                } else {
                    fixSection.style.display = 'none';
                }
                
                // Display malformed entries
                let entriesHtml = '<div class="malformed-entries">';
                data.malformed_entries.forEach(entry => {
                    let statusClass = '';
                    let statusText = '';
                    let conversionPreview = '';
                    
                    if (entry.type === 'python_list') {
                        statusClass = 'fixable';
                        statusText = '‚úÖ Can convert Python list to JSON';
                        conversionPreview = `<div class="conversion-preview">
                            <strong>Will convert to:</strong> <code>${entry.converted_json}</code>
                        </div>`;
                    } else if (entry.type === 'python_string') {
                        statusClass = 'fixable';
                        statusText = '‚úÖ Can convert Python string to JSON array';
                        conversionPreview = `<div class="conversion-preview">
                            <strong>Will convert to:</strong> <code>${entry.converted_json}</code>
                        </div>`;
                    } else if (entry.type === 'truly_malformed') {
                        statusClass = 'unfixable';
                        statusText = '‚ùå Cannot auto-fix: ' + entry.error;
                    } else {
                        statusClass = 'unfixable';
                        statusText = '‚ùå Unknown format: ' + (entry.error || entry.type);
                    }
                    
                    // In displayMalformedResults function, update the entry display part:
                    entriesHtml += `
                        <div class="malformed-entry ${statusClass}">
                            <div class="entry-header">
                                <strong>Table:</strong> ${entry.table}<br>
                                <strong>Column:</strong> ${entry.column}<br>
                                <strong>Entry ID:</strong> ${entry.entry_id}<br>
                                <strong>Value:</strong> ${entry.value || 'N/A'}
                            </div>
                            <div class="entry-details">
                                <strong>Current Text:</strong> <code class="current-text">${entry.current_text}</code><br>
                                <strong>Status:</strong> <span class="status-${statusClass}">${statusText}</span>
                                ${conversionPreview}
                            </div>
                        </div>
                    `;
                });
                entriesHtml += '</div>';
                
                entriesList.innerHTML = entriesHtml;
            }
            
            resultsDiv.style.display = 'block';
        }


        let currentInvalidUrls = [];

        function checkInvalidImageUrls() {
            console.log("DEBUG: Starting invalid image URLs check...");
            const checkBtn = document.getElementById('urls-check-btn');
            const loading = document.getElementById('urls-check-loading');
            const resultsDiv = document.getElementById('urls-results');
            
            checkBtn.disabled = true;
            loading.style.display = 'block';
            resultsDiv.style.display = 'none';
            
            fetch('/check_invalid_image_urls', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => {
                console.log("DEBUG: Got response from URLs check:", response.status);
                return response.json();
            })
            .then(data => {
                console.log("DEBUG: URLs check data:", data);
                if (data.success) {
                    currentInvalidUrls = data.invalid_entries;
                    console.log("DEBUG: Found", data.total_invalid, "images with invalid URLs");
                    displayUrlsResults(data);
                } else {
                    console.error("DEBUG: Error in URLs check:", data.error);
                    alert('Error checking image URLs: ' + data.error);
                }
            })
            .catch(error => {
                console.error('DEBUG: Fetch error in URLs check:', error);
                alert('Failed to check image URLs');
            })
            .finally(() => {
                checkBtn.disabled = false;
                loading.style.display = 'none';
            });
        }

        function displayUrlsResults(data) {
            console.log("DEBUG: Displaying URLs results:", data);
            const resultsDiv = document.getElementById('urls-results');
            const titleEl = document.getElementById('urls-results-title');
            const summaryEl = document.getElementById('urls-results-summary');
            const fixSection = document.getElementById('urls-fix-section');
            const urlsList = document.getElementById('urls-list');
            
            if (data.total_invalid === 0) {
                titleEl.textContent = '‚úÖ All Image URLs Are Valid';
                summaryEl.innerHTML = '<div class="success">No invalid image URLs found!</div>';
                fixSection.style.display = 'none';
                urlsList.innerHTML = '';
            } else {
                titleEl.textContent = `‚ö†Ô∏è Found ${data.total_invalid} Images with Invalid URLs`;
                summaryEl.innerHTML = `
                    <div class="warning">
                        <strong>${data.total_invalid}</strong> images have invalid or broken URLs<br>
                        <small>Checked ${data.total_checked} total images</small>
                    </div>
                `;
                fixSection.style.display = 'block';
                
                // Display invalid entries
                let urlsHtml = '<div class="invalid-urls-list">';
                data.invalid_entries.forEach(entry => {
                    let statusClass = entry.type === 'json_error' ? 'json-error' : 'broken-urls';
                    let invalidUrlsHtml = '';
                    
                    if (entry.invalid_urls && entry.invalid_urls.length > 0) {
                        invalidUrlsHtml = '<strong>Invalid URLs:</strong><ul>';
                        entry.invalid_urls.forEach(invalid => {
                            invalidUrlsHtml += `<li><strong>${invalid.size}:</strong> ${invalid.error} - <code>${invalid.url}</code></li>`;
                        });
                        invalidUrlsHtml += '</ul>';
                    }
                    
                    let validUrlsHtml = '';
                    if (entry.valid_urls && Object.keys(entry.valid_urls).length > 0) {
                        validUrlsHtml = `<br><strong>Valid URLs:</strong> ${Object.keys(entry.valid_urls).join(', ')}`;
                    }
                    
                    urlsHtml += `
                        <div class="invalid-url-entry ${statusClass}">
                            <div class="entry-header">
                                <strong>Image ID:</strong> ${entry.image_id}<br>
                                <strong>Value:</strong> ${entry.value || 'N/A'}
                            </div>
                            <div class="entry-details">
                                ${entry.error ? `<strong>Error:</strong> ${entry.error}<br>` : ''}
                                ${invalidUrlsHtml}
                                ${validUrlsHtml}
                                ${entry.total_urls ? `<br><strong>Total URLs:</strong> ${entry.total_urls}` : ''}
                            </div>
                        </div>
                    `;
                });
                urlsHtml += '</div>';
                urlsList.innerHTML = urlsHtml;
            }
            
            resultsDiv.style.display = 'block';
        }

        function fixInvalidImageUrls(action) {
            console.log("DEBUG: Starting fix invalid URLs with action:", action);
            if (currentInvalidUrls.length === 0) {
                alert('No invalid URLs to fix');
                return;
            }
            
            const actionText = action === 'remove' ? 'permanently delete' : 'clean URLs for';
            if (!confirm(`Are you sure you want to ${actionText} ${currentInvalidUrls.length} image entries?`)) {
                console.log("DEBUG: User cancelled fix operation");
                return;
            }
            
            const cleanBtn = document.getElementById('urls-clean-btn');
            const removeBtn = document.getElementById('urls-remove-btn');
            const loading = document.getElementById('urls-fix-loading');
            const successDiv = document.getElementById('urls-success');
            
            cleanBtn.disabled = true;
            removeBtn.disabled = true;
            loading.style.display = 'block';
            successDiv.style.display = 'none';
            
            fetch('/fix_invalid_image_urls', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    invalid_entries: currentInvalidUrls,
                    action: action
                })
            })
            .then(response => {
                console.log("DEBUG: Fix URLs response status:", response.status);
                return response.json();
            })
            .then(data => {
                console.log("DEBUG: Fix URLs response data:", data);
                if (data.success) {
                    successDiv.innerHTML = `
                        <div class="success">
                            ‚úÖ ${data.message}
                            <br>Database has been updated.
                        </div>
                    `;
                    successDiv.style.display = 'block';
                    
                    document.getElementById('urls-fix-section').style.display = 'none';
                    currentInvalidUrls = [];
                    
                    setTimeout(() => {
                        document.getElementById('urls-results').style.display = 'none';
                        loadDatabaseStats(); // Refresh stats
                    }, 3000);
                } else {
                    console.error("DEBUG: Error in fix response:", data.error);
                    alert('Error fixing URLs: ' + data.error);
                }
            })
            .catch(error => {
                console.error('DEBUG: Fetch error in fix URLs:', error);
                alert('Failed to fix URLs');
            })
            .finally(() => {
                cleanBtn.disabled = false;
                removeBtn.disabled = false;
                loading.style.display = 'none';
            });
        }

        function fixMalformedJson() {
            if (currentMalformedEntries.length === 0) {
                alert('No malformed entries to fix');
                return;
            }
            
            const fixableCount = currentMalformedEntries.filter(e => e.converted_json !== null).length;
            if (fixableCount === 0) {
                alert('No entries can be automatically fixed');
                return;
            }
            
            if (!confirm(`Are you sure you want to convert ${fixableCount} entries to proper JSON format?`)) {
                return;
            }
            
            const fixBtn = document.getElementById('json-fix-btn');
            const loading = document.getElementById('json-fix-loading');
            const successDiv = document.getElementById('json-fix-success');
            
            fixBtn.disabled = true;
            loading.style.display = 'block';
            successDiv.style.display = 'none';
            
            fetch('/fix_malformed_json', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    malformed_entries: currentMalformedEntries
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    successDiv.innerHTML = `
                        <div class="success">
                            ‚úÖ ${data.message}
                            <br>You can now run the orphaned image check to verify the fixes.
                        </div>
                    `;
                    successDiv.style.display = 'block';
                    
                    document.getElementById('json-fix-section').style.display = 'none';
                    currentMalformedEntries = [];
                    
                    setTimeout(() => {
                        document.getElementById('json-results').style.display = 'none';
                        loadDatabaseStats(); // Refresh stats
                    }, 3000);
                } else {
                    alert('Error fixing JSON: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Failed to fix JSON');
            })
            .finally(() => {
                fixBtn.disabled = false;
                loading.style.display = 'none';
            });
        }


        let currentArtistsWithoutImages = [];

        function checkArtistsWithoutImages() {
            console.log("DEBUG: Starting artists without images check...");
            const checkBtn = document.getElementById('artists-check-btn');
            const loading = document.getElementById('artists-check-loading');
            const resultsDiv = document.getElementById('artists-results');
            
            checkBtn.disabled = true;
            loading.style.display = 'block';
            resultsDiv.style.display = 'none';
            
            fetch('/check_artists_without_images', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => {
                console.log("DEBUG: Got response from artists check:", response.status);
                return response.json();
            })
            .then(data => {
                console.log("DEBUG: Artists check data:", data);
                if (data.success) {
                    currentArtistsWithoutImages = data.artists_without_images;
                    console.log("DEBUG: Found", data.total_artists_without_images, "artists without images");
                    displayArtistsResults(data);
                } else {
                    console.error("DEBUG: Error in artists check:", data.error);
                    alert('Error checking artists: ' + data.error);
                }
            })
            .catch(error => {
                console.error('DEBUG: Fetch error in artists check:', error);
                alert('Failed to check artists');
            })
            .finally(() => {
                checkBtn.disabled = false;
                loading.style.display = 'none';
            });
        }

        function displayArtistsResults(data) {
            console.log("DEBUG: Displaying artists results:", data);
            const resultsDiv = document.getElementById('artists-results');
            const titleEl = document.getElementById('artists-results-title');
            const summaryEl = document.getElementById('artists-results-summary');
            const actionSection = document.getElementById('artists-action-section');
            const removeSection = document.getElementById('artists-remove-section');
            const artistsList = document.getElementById('artists-list');
            
            if (data.total_artists_without_images === 0) {
                titleEl.textContent = '‚úÖ All Artists Have Images';
                summaryEl.innerHTML = '<div class="success">No artists without images found!</div>';
                actionSection.style.display = 'none';
                removeSection.style.display = 'none';
                artistsList.innerHTML = '';
            } else {
                titleEl.textContent = `‚ö†Ô∏è Found ${data.total_artists_without_images} Artists Without Images`;
                summaryEl.innerHTML = `
                    <div class="warning">
                        <strong>${data.total_artists_without_images}</strong> artists have no associated artwork
                    </div>
                `;
                actionSection.style.display = 'block';
                removeSection.style.display = 'block';
                
                // Display artists without images (simplified version without individual search buttons)
                let artistsHtml = '<div class="artists-without-images">';
                data.artists_without_images.forEach(artist => {
                    const aliasesText = artist.aliases && artist.aliases.length > 0 ? 
                        `<br><strong>Aliases:</strong> ${JSON.stringify(artist.aliases)}` : '';
                    
                    artistsHtml += `
                        <div class="artist-entry">
                            <div class="entry-header">
                                <strong>Artist:</strong> ${artist.value || 'N/A'}<br>
                                <strong>Entry ID:</strong> ${artist.entry_id}
                                ${aliasesText}
                            </div>
                            <div class="entry-details">
                                <strong>Images:</strong> ${artist.images || 'NULL'}
                            </div>
                        </div>
                    `;
                });
                artistsHtml += '</div>';
                artistsList.innerHTML = artistsHtml;
            }
            
            resultsDiv.style.display = 'block';
        }

        let currentSearchResults = null;

        function searchAllRelatedArtworks() {
            console.log("DEBUG: Starting search for all related artworks...");
            const searchBtn = document.getElementById('search-all-btn');
            const loading = document.getElementById('search-all-loading');
            const searchResultsSection = document.getElementById('search-results-section');
            
            searchBtn.disabled = true;
            loading.style.display = 'block';
            searchResultsSection.style.display = 'none';
            
            fetch('/search_all_related_artworks', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => {
                console.log("DEBUG: Search all related artworks response status:", response.status);
                return response.json();
            })
            .then(data => {
                console.log("DEBUG: Search all related artworks response data:", data);
                if (data.success) {
                    currentSearchResults = data;
                    displaySearchResults(data);
                } else {
                    console.error("DEBUG: Error in search all related artworks:", data.error);
                    alert('Error searching for related artworks: ' + data.error);
                }
            })
            .catch(error => {
                console.error('DEBUG: Fetch error in search all related artworks:', error);
                alert('Failed to search for related artworks');
            })
            .finally(() => {
                searchBtn.disabled = false;
                loading.style.display = 'none';
            });
        }

        function displaySearchResults(data) {
            const searchResultsSection = document.getElementById('search-results-section');
            const titleEl = document.getElementById('search-results-title');
            const summaryEl = document.getElementById('search-results-summary');
            const executeSection = document.getElementById('execute-action-section');
            const detailsDiv = document.getElementById('search-results-details');
            
            titleEl.textContent = `üîç Search Results`;
            summaryEl.innerHTML = `
                <div class="info">
                    <strong>${data.total_with_matches}</strong> artists have related artworks<br>
                    <strong>${data.total_without_matches}</strong> artists have no related artworks
                </div>
            `;
            
            if (data.total_with_matches > 0 || data.total_without_matches > 0) {
                executeSection.style.display = 'block';
            }
            
            let detailsHtml = '';
            
            // Show artists with matches
            if (data.total_with_matches > 0) {
                detailsHtml += `<h4>‚úÖ Artists with Related Artworks (${data.total_with_matches})</h4>`;
                detailsHtml += '<div class="artists-with-matches">';
                data.artists_with_matches.forEach(artist => {
                    const aliasesText = artist.aliases && artist.aliases.length > 0 ? 
                        `<br><strong>Aliases:</strong> ${JSON.stringify(artist.aliases)}` : '';
                    
                    detailsHtml += `
                        <div class="artist-match-entry">
                            <div class="entry-header">
                                <strong>Artist:</strong> ${artist.value}<br>
                                <strong>Entry ID:</strong> ${artist.entry_id}
                                ${aliasesText}
                            </div>
                            <div class="entry-details">
                                <strong>Found ${artist.total_related} related artwork(s):</strong>
                                <ul>
                    `;
                    artist.related_images.forEach(image => {
                        detailsHtml += `<li><strong>${image.value}</strong> (ID: ${image.image_id})</li>`;
                    });
                    detailsHtml += `
                                </ul>
                            </div>
                        </div>
                    `;
                });
                detailsHtml += '</div>';
            }
            
            // Show artists without matches
            if (data.total_without_matches > 0) {
                detailsHtml += `<h4>‚ùå Artists without Related Artworks (${data.total_without_matches})</h4>`;
                detailsHtml += '<div class="artists-without-matches">';
                data.artists_without_matches.forEach(artist => {
                    const aliasesText = artist.aliases && artist.aliases.length > 0 ? 
                        `<br><strong>Aliases:</strong> ${JSON.stringify(artist.aliases)}` : '';
                    
                    detailsHtml += `
                        <div class="artist-no-match-entry">
                            <div class="entry-header">
                                <strong>Artist:</strong> ${artist.value}<br>
                                <strong>Entry ID:</strong> ${artist.entry_id}
                                ${aliasesText}
                            </div>
                            <div class="entry-details">
                                <em>No related artworks found - will be removed</em>
                            </div>
                        </div>
                    `;
                });
                detailsHtml += '</div>';
            }
            
            detailsDiv.innerHTML = detailsHtml;
            searchResultsSection.style.display = 'block';
        }

        function executeArtistUpdates() {
            console.log("DEBUG: Starting execute artist updates...");
            if (!currentSearchResults) {
                alert('No search results to execute');
                return;
            }
            
            const updatesCount = currentSearchResults.total_with_matches;
            const removalsCount = currentSearchResults.total_without_matches;
            
            if (!confirm(`Are you sure you want to execute these updates?\n\n- Update ${updatesCount} artists with new images\n- Remove ${removalsCount} artists without matches\n\nThis cannot be undone.`)) {
                console.log("DEBUG: User cancelled execute operation");
                return;
            }
            
            const executeBtn = document.getElementById('execute-updates-btn');
            const loading = document.getElementById('execute-loading');
            const successDiv = document.getElementById('artists-success');
            
            executeBtn.disabled = true;
            loading.style.display = 'block';
            successDiv.style.display = 'none';
            
            fetch('/execute_artist_updates', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    artists_with_matches: currentSearchResults.artists_with_matches,
                    artists_without_matches: currentSearchResults.artists_without_matches
                })
            })
            .then(response => {
                console.log("DEBUG: Execute artist updates response status:", response.status);
                return response.json();
            })
            .then(data => {
                console.log("DEBUG: Execute artist updates response data:", data);
                if (data.success) {
                    successDiv.innerHTML = `
                        <div class="success">
                            ‚úÖ ${data.message}
                            <br>Database has been updated.
                        </div>
                    `;
                    successDiv.style.display = 'block';
                    
                    // Hide all action sections
                    document.getElementById('artists-action-section').style.display = 'none';
                    document.getElementById('search-results-section').style.display = 'none';
                    document.getElementById('artists-remove-section').style.display = 'none';
                    currentSearchResults = null;
                    
                    setTimeout(() => {
                        document.getElementById('artists-results').style.display = 'none';
                        loadDatabaseStats(); // Refresh stats
                    }, 3000);
                } else {
                    console.error("DEBUG: Error in execute response:", data.error);
                    alert('Error executing updates: ' + data.error);
                }
            })
            .catch(error => {
                console.error('DEBUG: Fetch error in execute artist updates:', error);
                alert('Failed to execute updates');
            })
            .finally(() => {
                executeBtn.disabled = false;
                loading.style.display = 'none';
            });
        }

        function removeArtistsWithoutImages() {
            console.log("DEBUG: Starting remove artists without images...");
            if (currentArtistsWithoutImages.length === 0) {
                alert('No artists to remove');
                return;
            }
            
            if (!confirm(`Are you sure you want to permanently delete ${currentArtistsWithoutImages.length} artists? This cannot be undone.`)) {
                console.log("DEBUG: User cancelled remove operation");
                return;
            }
            
            const removeBtn = document.getElementById('artists-remove-btn');
            const loading = document.getElementById('artists-remove-loading');
            const successDiv = document.getElementById('artists-success');
            
            removeBtn.disabled = true;
            loading.style.display = 'block';
            successDiv.style.display = 'none';
            
            fetch('/remove_artists_without_images', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    artists_to_remove: currentArtistsWithoutImages
                })
            })
            .then(response => {
                console.log("DEBUG: Remove artists response status:", response.status);
                return response.json();
            })
            .then(data => {
                console.log("DEBUG: Remove artists response data:", data);
                if (data.success) {
                    successDiv.innerHTML = `
                        <div class="success">
                            ‚úÖ ${data.message}
                            <br>Database has been updated.
                        </div>
                    `;
                    successDiv.style.display = 'block';
                    
                    document.getElementById('artists-remove-section').style.display = 'none';
                    currentArtistsWithoutImages = [];
                    
                    setTimeout(() => {
                        document.getElementById('artists-results').style.display = 'none';
                        loadDatabaseStats(); // Refresh stats
                    }, 3000);
                } else {
                    console.error("DEBUG: Error in remove response:", data.error);
                    alert('Error removing artists: ' + data.error);
                }
            })
            .catch(error => {
                console.error('DEBUG: Fetch error in remove artists:', error);
                alert('Failed to remove artists');
            })
            .finally(() => {
                removeBtn.disabled = false;
                loading.style.display = 'none';
            });
        }

        // New function for checking artist-image integrity
        function checkArtistImageIntegrity() {
            console.log("DEBUG: Starting artist-image integrity check...");
            const checkBtn = document.getElementById('integrity-check-btn');
            const loading = document.getElementById('integrity-check-loading');
            const resultsDiv = document.getElementById('integrity-results');
            
            checkBtn.disabled = true;
            loading.style.display = 'block';
            resultsDiv.style.display = 'none';
            
            fetch('/check_artist_image_integrity', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => {
                console.log("DEBUG: Artist-image integrity check response status:", response.status);
                return response.json();
            })
            .then(data => {
                console.log("DEBUG: Artist-image integrity check response data:", data);
                if (data.success) {
                    currentIntegrityIssues = data.integrity_issues;
                    console.log("DEBUG: Found", data.total_issues, "integrity issues");
                    displayIntegrityResults(data);
                } else {
                    console.error("DEBUG: Error in artist-image integrity check:", data.error);
                    alert('Error checking artist-image integrity: ' + data.error);
                }
            })
            .catch(error => {
                console.error('DEBUG: Fetch error in artist-image integrity check:', error);
                alert('Failed to check artist-image integrity');
            })
            .finally(() => {
                checkBtn.disabled = false;
                loading.style.display = 'none';
            });
        }

        let currentIntegrityIssues = [];

        function displayIntegrityResults(data) {
            const resultsDiv = document.getElementById('integrity-results');
            const titleEl = document.getElementById('integrity-results-title');
            const summaryEl = document.getElementById('integrity-results-summary');
            const fixSection = document.getElementById('integrity-fix-section');
            const issuesList = document.getElementById('integrity-issues-list');
            
            if (data.total_issues === 0) {
                titleEl.textContent = '‚úÖ Artist-Image Integrity Check Complete';
                summaryEl.innerHTML = '<div class="success">All artist-image relationships are correct!</div>';
                fixSection.style.display = 'none';
                issuesList.innerHTML = '';
            } else {
                titleEl.textContent = `‚ö†Ô∏è Found ${data.total_issues} Artist-Image Integrity Issues`;
                summaryEl.innerHTML = `
                    <div class="warning">
                        <strong>${data.total_issues}</strong> integrity issues found
                    </div>
                `;
                fixSection.style.display = 'block';
                
                // Group issues by type
                const issuesByType = {
                    'missing_image': [],
                    'missing_artist_name': [],
                    'missing_related_keyword': [],
                    'malformed_json': []
                };
                
                data.integrity_issues.forEach(issue => {
                    if (issuesByType[issue.type]) {
                        issuesByType[issue.type].push(issue);
                    }
                });
                
                let issuesHtml = '<div class="integrity-issues">';
                
                // Display missing images
                if (issuesByType.missing_image.length > 0) {
                    issuesHtml += `<h4>üö´ Missing Images (${issuesByType.missing_image.length})</h4>`;
                    issuesByType.missing_image.forEach(issue => {
                        issuesHtml += `
                            <div class="issue-entry error">
                                <strong>Artist:</strong> ${issue.artist_name}<br>
                                <strong>Entry ID:</strong> ${issue.artist_entry_id}<br>
                                <strong>Missing Image ID:</strong> ${issue.image_id}<br>
                                <strong>Issue:</strong> ${issue.description}
                            </div>
                        `;
                    });
                }
                
                // Display missing artist names
                if (issuesByType.missing_artist_name.length > 0) {
                    issuesHtml += `<h4>üë§ Missing Artist Names (${issuesByType.missing_artist_name.length})</h4>`;
                    issuesByType.missing_artist_name.forEach(issue => {
                        issuesHtml += `
                            <div class="issue-entry warning">
                                <strong>Image:</strong> ${issue.image_value}<br>
                                <strong>Image ID:</strong> ${issue.image_id}<br>
                                <strong>Missing Artist:</strong> ${issue.artist_name}<br>
                                <strong>Current Artists:</strong> ${issue.current_artist_names.join(', ') || 'None'}<br>
                                <strong>Issue:</strong> ${issue.description}
                            </div>
                        `;
                    });
                }
                
                // Display missing related keywords
                if (issuesByType.missing_related_keyword.length > 0) {
                    issuesHtml += `<h4>üîó Missing Related Keywords (${issuesByType.missing_related_keyword.length})</h4>`;
                    issuesByType.missing_related_keyword.forEach(issue => {
                        issuesHtml += `
                            <div class="issue-entry warning">
                                <strong>Image:</strong> ${issue.image_value}<br>
                                <strong>Image ID:</strong> ${issue.image_id}<br>
                                <strong>Missing Artist Entry ID:</strong> ${issue.artist_entry_id}<br>
                                <strong>Artist Name:</strong> ${issue.artist_name}<br>
                                <strong>Issue:</strong> ${issue.description}
                            </div>
                        `;
                    });
                }
                
                // Display malformed JSON
                if (issuesByType.malformed_json.length > 0) {
                    issuesHtml += `<h4>üìù Malformed JSON (${issuesByType.malformed_json.length})</h4>`;
                    issuesByType.malformed_json.forEach(issue => {
                        issuesHtml += `
                            <div class="issue-entry error">
                                <strong>Artist:</strong> ${issue.artist_name}<br>
                                <strong>Entry ID:</strong> ${issue.artist_entry_id}<br>
                                <strong>Issue:</strong> ${issue.description}<br>
                                <strong>Malformed JSON:</strong> <code>${issue.images_json}</code>
                            </div>
                        `;
                    });
                }
                
                issuesHtml += '</div>';
                issuesList.innerHTML = issuesHtml;
            }
            
            resultsDiv.style.display = 'block';
        }

        function fixArtistImageIntegrity() {
            console.log("DEBUG: Starting fix artist-image integrity...");
            if (currentIntegrityIssues.length === 0) {
                alert('No integrity issues to fix');
                return;
            }
            
            if (!confirm(`Are you sure you want to fix ${currentIntegrityIssues.length} integrity issues? This will modify your database.`)) {
                console.log("DEBUG: User cancelled fix operation");
                return;
            }
            
            const fixBtn = document.getElementById('integrity-fix-btn');
            const loading = document.getElementById('integrity-fix-loading');
            const successDiv = document.getElementById('integrity-fix-success');
            
            fixBtn.disabled = true;
            loading.style.display = 'block';
            successDiv.style.display = 'none';
            
            fetch('/fix_artist_image_integrity', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    integrity_issues: currentIntegrityIssues
                })
            })
            .then(response => {
                console.log("DEBUG: Fix artist-image integrity response status:", response.status);
                return response.json();
            })
            .then(data => {
                console.log("DEBUG: Fix artist-image integrity response data:", data);
                if (data.success) {
                    successDiv.innerHTML = `
                        <div class="success">
                            ‚úÖ ${data.message}
                            <br>Database has been updated.
                        </div>
                    `;
                    successDiv.style.display = 'block';
                    
                    document.getElementById('integrity-fix-section').style.display = 'none';
                    currentIntegrityIssues = [];
                    
                    setTimeout(() => {
                        document.getElementById('integrity-results').style.display = 'none';
                        loadDatabaseStats(); // Refresh stats
                    }, 3000);
                } else {
                    console.error("DEBUG: Error in fix response:", data.error);
                    alert('Error fixing integrity issues: ' + data.error);
                }
            })
            .catch(error => {
                console.error('DEBUG: Fetch error in fix artist-image integrity:', error);
                alert('Failed to fix integrity issues');
            })
            .finally(() => {
                fixBtn.disabled = false;
                loading.style.display = 'none';
            });
        }

        function checkOrphanedImages() {
            console.log("DEBUG: Starting orphaned images check...");
            const checkBtn = document.getElementById('check-btn');
            const loading = document.getElementById('check-loading');
            const resultsDiv = document.getElementById('orphaned-results');
            
            checkBtn.disabled = true;
            loading.style.display = 'block';
            resultsDiv.style.display = 'none';
            
            fetch('/check_orphaned_images', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => {
                console.log("DEBUG: Got response from orphaned images check:", response.status);
                return response.json();
            })
            .then(data => {
                console.log("DEBUG: Orphaned images check data:", data);
                if (data.success) {
                    currentFaultyEntries = data.faulty_entries;
                    console.log("DEBUG: Found", data.total_faulty, "faulty entries");
                    displayOrphanedResults(data);
                } else {
                    console.error("DEBUG: Error in orphaned images check:", data.error);
                    alert('Error checking orphaned images: ' + data.error);
                }
            })
            .catch(error => {
                console.error('DEBUG: Fetch error in orphaned images check:', error);
                alert('Failed to check orphaned images');
            })
            .finally(() => {
                checkBtn.disabled = false;
                loading.style.display = 'none';
            });
        }

        function displayOrphanedResults(data) {
            const resultsDiv = document.getElementById('orphaned-results');
            const titleEl = document.getElementById('results-title');
            const summaryEl = document.getElementById('results-summary');
            const fixSection = document.getElementById('fix-section');
            const entriesList = document.getElementById('faulty-entries-list');
            
            if (data.total_faulty === 0) {
                titleEl.textContent = '‚úÖ No Orphaned References Found';
                summaryEl.innerHTML = '<div class="success">All image references are valid!</div>';
                fixSection.style.display = 'none';
                entriesList.innerHTML = '';
            } else {
                titleEl.textContent = `‚ö†Ô∏è Found ${data.total_faulty} Entries with Orphaned References`;
                summaryEl.innerHTML = `
                    <div class="warning">
                        <strong>${data.total_faulty}</strong> text entries have invalid image references<br>
                        Database contains <strong>${data.total_valid_images}</strong> valid images
                    </div>
                `;
                fixSection.style.display = 'block';
                
                // Display faulty entries
                let entriesHtml = '<div class="faulty-entries">';
                data.faulty_entries.forEach(entry => {
                    const invalidIdsHtml = entry.invalid_image_ids.map(id => 
                        `<span class="invalid-id">${id}</span>`
                    ).join(', ');
                    
                    const validIdsHtml = entry.valid_image_ids.length > 0 ? 
                        `<br><strong>Valid IDs:</strong> ${entry.valid_image_ids.join(', ')}` : '';
                    
                    entriesHtml += `
                        <div class="faulty-entry">
                            <div class="entry-header">
                                <strong>Entry ID:</strong> ${entry.entry_id}<br>
                                <strong>Value:</strong> ${entry.value || 'N/A'}
                            </div>
                            <div class="entry-details">
                                <strong>Invalid Image IDs:</strong> ${invalidIdsHtml}
                                ${validIdsHtml}
                                <br><strong>Total Refs:</strong> ${entry.total_image_refs}
                                ${entry.json_error ? '<br><span class="json-error">‚ö†Ô∏è Malformed JSON</span>' : ''}
                            </div>
                        </div>
                    `;
                });
                entriesHtml += '</div>';
                entriesList.innerHTML = entriesHtml;
            }
            
            resultsDiv.style.display = 'block';
        }

        function fixOrphanedImages() {
            console.log("DEBUG: Starting fix orphaned images...");
            console.log("DEBUG: Current faulty entries:", currentFaultyEntries);
            
            if (currentFaultyEntries.length === 0) {
                console.log("DEBUG: No faulty entries to fix");
                alert('No faulty entries to fix');
                return;
            }
            
            if (!confirm(`Are you sure you want to fix ${currentFaultyEntries.length} entries? This will permanently remove invalid image references.`)) {
                console.log("DEBUG: User cancelled fix operation");
                return;
            }
            
            const fixBtn = document.getElementById('fix-btn');
            const loading = document.getElementById('fix-loading');
            const successDiv = document.getElementById('fix-success');
            
            console.log("DEBUG: Starting fetch to fix orphaned images...");
            
            fixBtn.disabled = true;
            loading.style.display = 'block';
            successDiv.style.display = 'none';
            
            const requestData = {
                faulty_entries: currentFaultyEntries
            };
            console.log("DEBUG: Sending request data:", requestData);
            
            fetch('/fix_orphaned_images', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestData)
            })
            .then(response => {
                console.log("DEBUG: Fix orphaned images response status:", response.status);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log("DEBUG: Fix orphaned images response data:", data);
                if (data.success) {
                    successDiv.innerHTML = `
                        <div class="success">
                            ‚úÖ ${data.message}
                            <br>You can now run the check again to verify the fixes.
                        </div>
                    `;
                    successDiv.style.display = 'block';
                    
                    // Hide the fix section and clear current data
                    document.getElementById('fix-section').style.display = 'none';
                    currentFaultyEntries = [];
                    
                    // Clear the results to encourage re-checking
                    setTimeout(() => {
                        document.getElementById('orphaned-results').style.display = 'none';
                        loadDatabaseStats(); // Refresh stats
                    }, 3000);
                } else {
                    console.error("DEBUG: Error in fix response:", data.error);
                    alert('Error fixing entries: ' + data.error);
                }
            })
            .catch(error => {
                console.error('DEBUG: Fetch error in fix orphaned images:', error);
                alert('Failed to fix entries: ' + error.message);
            })
            .finally(() => {
                console.log("DEBUG: Fix orphaned images operation completed");
                fixBtn.disabled = false;
                loading.style.display = 'none';
            });
        }

        let currentKeywordIssues = [];

        function checkRelatedKeywords() {
            console.log("DEBUG: Starting related keywords check...");
            const checkBtn = document.getElementById('keywords-check-btn');
            const loading = document.getElementById('keywords-check-loading');
            const resultsDiv = document.getElementById('keywords-results');
            
            checkBtn.disabled = true;
            loading.style.display = 'block';
            resultsDiv.style.display = 'none';
            
            fetch('/check_related_keywords', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => {
                console.log("DEBUG: Got response from keywords check:", response.status);
                return response.json();
            })
            .then(data => {
                console.log("DEBUG: Keywords check data:", data);
                if (data.success) {
                    currentKeywordIssues = data.issues;
                    console.log("DEBUG: Found", data.total_issues, "entries with keyword issues");
                    displayKeywordResults(data);
                } else {
                    console.error("DEBUG: Error in keywords check:", data.error);
                    alert('Error checking related keywords: ' + data.error);
                }
            })
            .catch(error => {
                console.error('DEBUG: Fetch error in keywords check:', error);
                alert('Failed to check related keywords');
            })
            .finally(() => {
                checkBtn.disabled = false;
                loading.style.display = 'none';
            });
        }

        function displayKeywordResults(data) {
            console.log("DEBUG: Displaying keyword results:", data);
            const resultsDiv = document.getElementById('keywords-results');
            const titleEl = document.getElementById('keywords-results-title');
            const summaryEl = document.getElementById('keywords-results-summary');
            const fixSection = document.getElementById('keywords-fix-section');
            const issuesList = document.getElementById('keywords-issues-list');
            
            if (data.total_issues === 0) {
                titleEl.textContent = '‚úÖ All Related Keywords Are Valid';
                summaryEl.innerHTML = '<div class="success">No keyword reference issues found!</div>';
                fixSection.style.display = 'none';
                issuesList.innerHTML = '';
            } else {
                titleEl.textContent = `‚ö†Ô∏è Found ${data.total_issues} Entries with Keyword Issues`;
                
                // Count different types of issues
                let invalidIdCount = 0;
                let mismatchCount = 0;
                data.issues.forEach(issue => {
                    if (issue.has_invalid_ids) invalidIdCount++;
                    if (issue.strings_mismatch) mismatchCount++;
                });
                
                summaryEl.innerHTML = `
                    <div class="warning">
                        <strong>${data.total_issues}</strong> entries have keyword reference issues<br>
                        <strong>${invalidIdCount}</strong> have invalid keyword IDs<br>
                        <strong>${mismatchCount}</strong> have mismatched keyword strings<br>
                        <small>Total valid entries in database: ${data.total_valid_entries}</small>
                    </div>
                `;
                fixSection.style.display = 'block';
                
                // Display issues
                let issuesHtml = '<div class="keyword-issues-list">';
                data.issues.forEach(issue => {
                    let issueTypes = [];
                    if (issue.has_invalid_ids) issueTypes.push('Invalid IDs');
                    if (issue.strings_mismatch) issueTypes.push('String Mismatch');
                    
                    let invalidIdsHtml = '';
                    if (issue.invalid_ids && issue.invalid_ids.length > 0) {
                        invalidIdsHtml = `<br><strong>Invalid IDs:</strong> ${issue.invalid_ids.map(id => 
                            `<span class="invalid-id">${id}</span>`
                        ).join(', ')}`;
                    }
                    
                    let stringsComparisonHtml = '';
                    if (issue.strings_mismatch) {
                        const currentStrings = issue.current_strings || [];
                        const correctStrings = issue.correct_strings || [];
                        stringsComparisonHtml = `
                            <div class="strings-comparison">
                                <div class="current-strings">
                                    <strong>Current Strings:</strong><br>
                                    ${currentStrings.length > 0 ? currentStrings.map(s => `"${s}"`).join(', ') : '<em>None</em>'}
                                </div>
                                <div class="correct-strings">
                                    <strong>Should Be:</strong><br>
                                    ${correctStrings.length > 0 ? correctStrings.map(s => `"${s}"`).join(', ') : '<em>None</em>'}
                                </div>
                            </div>
                        `;
                    }
                    
                    issuesHtml += `
                        <div class="keyword-issue-entry">
                            <div class="entry-header">
                                <strong>${issue.table === 'text_entries' ? 'Text Entry' : 'Image Entry'}:</strong> ${issue.value || 'N/A'}<br>
                                <strong>ID:</strong> ${issue.entry_id}<br>
                                <strong>Issues:</strong> <span class="issue-types">${issueTypes.join(', ')}</span>
                            </div>
                            <div class="entry-details">
                                <strong>Valid IDs:</strong> ${issue.valid_ids && issue.valid_ids.length > 0 ? issue.valid_ids.join(', ') : '<em>None</em>'}
                                ${invalidIdsHtml}
                                ${stringsComparisonHtml}
                            </div>
                        </div>
                    `;
                });
                issuesHtml += '</div>';
                issuesList.innerHTML = issuesHtml;
            }
            
            resultsDiv.style.display = 'block';
        }

        function fixRelatedKeywords() {
            console.log("DEBUG: Starting fix related keywords...");
            if (currentKeywordIssues.length === 0) {
                alert('No keyword issues to fix');
                return;
            }
            
            if (!confirm(`Are you sure you want to fix ${currentKeywordIssues.length} entries? This will remove invalid IDs and rebuild the keyword strings.`)) {
                console.log("DEBUG: User cancelled fix operation");
                return;
            }
            
            const fixBtn = document.getElementById('keywords-fix-btn');
            const loading = document.getElementById('keywords-fix-loading');
            const successDiv = document.getElementById('keywords-success');
            
            fixBtn.disabled = true;
            loading.style.display = 'block';
            successDiv.style.display = 'none';
            
            fetch('/fix_related_keywords', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    issues: currentKeywordIssues
                })
            })
            .then(response => {
                console.log("DEBUG: Fix keywords response status:", response.status);
                return response.json();
            })
            .then(data => {
                console.log("DEBUG: Fix keywords response data:", data);
                if (data.success) {
                    successDiv.innerHTML = `
                        <div class="success">
                            ‚úÖ ${data.message}
                            <br>Database has been updated with corrected keyword references.
                        </div>
                    `;
                    successDiv.style.display = 'block';
                    
                    document.getElementById('keywords-fix-section').style.display = 'none';
                    currentKeywordIssues = [];
                    
                    setTimeout(() => {
                        document.getElementById('keywords-results').style.display = 'none';
                        loadDatabaseStats(); // Refresh stats
                    }, 3000);
                } else {
                    console.error("DEBUG: Error in fix response:", data.error);
                    alert('Error fixing keyword references: ' + data.error);
                }
            })
            .catch(error => {
                console.error('DEBUG: Fetch error in fix keywords:', error);
                alert('Failed to fix keyword references');
            })
            .finally(() => {
                fixBtn.disabled = false;
                loading.style.display = 'none';
            });
        }
            
            
    </script>

    <style>
        .modal {
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        
        .data-cleaner-container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .cleaner-section {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .cleaner-section h3 {
            margin-top: 0;
            color: #343a40;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
        }
        
        .stats-grid {
            display: flex;
            gap: 15px;
            margin-top: 15px;
        }
        
        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
            text-align: center;
            flex: 1;
        }
        
        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
        }
        
        .stat-label {
            font-size: 12px;
            color: #6c757d;
            text-transform: uppercase;
        }
        
        .action-buttons {
            margin: 15px 0;
        }
        
        .btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
        }
        
        .btn:hover:not(:disabled) {
            background: #0056b3;
        }
        
        .btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        
        .btn-secondary {
            background: #6c757d;
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
        }
        
        .btn-secondary:hover:not(:disabled) {
            background: #545b62;
        }
        
        .btn-danger {
            background: #dc3545;
        }
        
        .btn-danger:hover:not(:disabled) {
            background: #c82333;
        }
        
        .btn-warning {
            background: #ffc107;
            color: #212529;
        }
        
        .btn-warning:hover:not(:disabled) {
            background: #e0a800;
        }
        
        .loading {
            display: none;
            color: #6c757d;
            font-style: italic;
            margin: 10px 0;
        }
        
        .results-header {
            margin-bottom: 20px;
        }
        
        .warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 10px;
            border-radius: 4px;
        }
        
        .success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 10px;
            border-radius: 4px;
        }
        
        .error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
            padding: 10px;
            border-radius: 4px;
        }
        
        .faulty-entries {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            border-radius: 4px;
        }
        
        .faulty-entry {
            padding: 15px;
            border-bottom: 1px solid #dee2e6;
            background: white;
        }
        
        .faulty-entry:last-child {
            border-bottom: none;
        }
        
        .entry-header {
            font-weight: 600;
            margin-bottom: 8px;
        }
        
        .entry-details {
            font-size: 14px;
            color: #495057;
        }
        
        .invalid-id {
            background: #f8d7da;
            color: #721c24;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            margin: 0 2px;
        }
        
        .json-error {
            background: #fff3cd;
            color: #856404;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 12px;
        }
        
        .warning-text {
            font-size: 12px;
            color: #856404;
            margin-top: 5px;
        }
        
        .success-message {
            margin-top: 15px;
        }
        
        .placeholder-buttons .btn {
            opacity: 0.6;
        }
        
        .malformed-entries {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            border-radius: 4px;
        }
        
        .malformed-entry {
            padding: 15px;
            border-bottom: 1px solid #dee2e6;
            background: white;
        }
        
        .malformed-entry:last-child {
            border-bottom: none;
        }
        
        .malformed-entry.fixable {
            border-left: 4px solid #28a745;
        }
        
        .malformed-entry.unfixable {
            border-left: 4px solid #dc3545;
        }
        
        .status-fixable {
            color: #28a745;
            font-weight: 600;
        }
        
        .status-unfixable {
            color: #dc3545;
            font-weight: 600;
        }
        
        .current-text {
            background: #f8f9fa;
            padding: 4px 8px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
            word-break: break-all;
        }
        
        .conversion-preview {
            margin-top: 8px;
            padding: 8px;
            background: #e8f5e8;
            border-radius: 4px;
            border-left: 3px solid #28a745;
        }
        
        .conversion-preview code {
            background: #fff;
            padding: 2px 4px;
            border-radius: 2px;
            font-size: 11px;
        }


        .keyword-issues-list {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            border-radius: 4px;
        }

        .keyword-issue-entry {
            padding: 15px;
            border-bottom: 1px solid #dee2e6;
            background: white;
        }

        .keyword-issue-entry:last-child {
            border-bottom: none;
        }

        .issue-types {
            color: #dc3545;
            font-weight: 600;
        }

        .strings-comparison {
            margin-top: 10px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .current-strings, .correct-strings {
            padding: 8px;
            background: #f8f9fa;
            border-radius: 4px;
            font-size: 13px;
        }

        .current-strings {
            border-left: 3px solid #dc3545;
        }

        .correct-strings {
            border-left: 3px solid #28a745;
        }

        .keyword-issue-entry .invalid-id {
            background: #f8d7da;
            color: #721c24;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            margin: 0 2px;
        }
        
        /* New styles for artist search results */
        .artists-with-matches, .artists-without-matches {
            margin: 15px 0;
        }
        
        .artist-match-entry, .artist-no-match-entry {
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
            border: 1px solid #dee2e6;
        }
        
        .artist-match-entry {
            background: #d4edda;
            border-left: 4px solid #28a745;
        }
        
        .artist-no-match-entry {
            background: #f8d7da;
            border-left: 4px solid #dc3545;
        }
        
        .artist-match-entry ul {
            margin: 5px 0 0 20px;
        }
        
        .artist-match-entry li {
            margin: 3px 0;
        }
        
        .btn-info {
            background: #17a2b8;
            color: white;
        }
        
        .btn-info:hover:not(:disabled) {
            background: #138496;
        }
        
        .info-text {
            font-size: 12px;
            color: #6c757d;
            margin-top: 5px;
        }
            </style>
    </body>
</html>